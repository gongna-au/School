# Python中的~~闭包~~

> 闭包的概念在go里面出现。然后发现python的
>
> ```
> @login_manager.user_loader
> def load_user(user_id):
>     from albumy.models import User
>     user = User.query.get(int(user_id))
>     return user
> 
> ```
>
> 和闭包好像？

## 1.什么是闭包?

> 维基上的解释:在[计算机科学](https://zh.m.wikipedia.org/wiki/计算机科学)中，**闭包**（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures），是在支持[头等函数](https://zh.m.wikipedia.org/wiki/头等函数)的编程语言中实现[词法](https://zh.m.wikipedia.org/wiki/作用域#静态作用域与动态作用域)[绑定](https://zh.m.wikipedia.org/wiki/名字绑定)的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括[约束变量](https://zh.m.wikipedia.org/wiki/约束变量)（该函数内部绑定的符号），也要包括[自由变量](https://zh.m.wikipedia.org/wiki/自由变量)（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。

- **一个函数**与一个**关联的环境**。
- 环境里既要包括**[约束变量]**该函数内部绑定的符号。
- 也要包括**[自由变量]**

###  闭包和状态表达

闭包可以用来在一个函数与一组“私有”变量之间建立关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所建立所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏

两个关键的地方： 

- 自由变量 和 函数,

- 还是得在赘述下“闭包”的意思，望文知意，可以形象的把它理解为一个封闭的包裹，这个包裹就是一个函数，当然还有函数内部对应的逻辑，包裹里面的东西就是自由变量，自由变量可以在随着包裹到处游荡。当然还得有个前提，这个包裹是被创建出来的。

- 在通过Python的语言介绍一下，一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。

  ```
  type returnFunc func()
  func A(name string) returnFunc {
  
  	rerurn func B(){
  		fmt.Println(name)
  	}
  }
  //因此这也意味着
  //当函数A的生命周期结束之后，name这个变量依然存在，因为它被闭包引用了，所以不会被回收。
  
  
  ```

  

## 2.**为什么使用闭包?**

这个东西和类有点相似，相似点在于他们都提供了对数据的封装。不同的是闭包本身就是个方法。和类一样，我们在编程时经常会把通用的东西抽象成类，(当然，还有对现实世界——业务的建模)，以复用通用的功能。闭包也是一样，当我们需要函数粒度的抽象时，闭包就是一个很好的选择。

- 闭包 打包了你传进来的数据，相当于你把某个数据存储在了某个结构体的成员变量当中。
- 在这点上闭包可以被理解为一个只读的对象，你可以给他传递一个属性，但它只能提供给你一个执行的接口。
- 因此在程序中我们经常需要这样的一个函数对象——闭包，来帮我们完成一个通用的功能，比如后面会提到的——装饰器。

## 3.**使用闭包**

## 4.Python修饰器的函数式编程

> Python的修饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去。

### 1.了解装饰模式

> **装饰模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

![装饰设计模式](https://refactoringguru.cn/images/patterns/content/decorator/decorator.png)

#### 问题

库的最初版本基于 `通知器`Notifier类， 其中只有很少的几个成员变量， 一个构造函数和一个 `send`发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。

![使用装饰模式前的库结构](https://refactoringguru.cn/images/patterns/diagrams/decorator/problem1-zh.png)

此后某个时刻， 你会发现库的用户希望使用除邮件通知之外的功能。 许多用户会希望接收关于紧急事件的手机短信， 还有些用户希望在微信上接收消息， 而公司用户则希望在 QQ 上接收消息。

![实现其他类型通知后的库结构](https://refactoringguru.cn/images/patterns/diagrams/decorator/problem2-zh.png)

每种通知类型都将作为通知器的一个子类得以实现。

这有什么难的呢？ 首先扩展 `通知器`类， 然后在新的子类中加入额外的通知方法。 现在客户端要对所需通知形式的对应类进行初始化， 然后使用该类发送后续所有的通知消息。

但这种方式会使得代码量迅速膨胀， 不仅仅是程序库代码， 客户端代码也会如此。你必须找到其他方法来规划通知类的结构， 否则它们的数量会在不经意之间打破吉尼斯纪录。

##### 解决

当你需要更改一个对象的行为时， 第一个跳入脑海的想法就是扩展它所属的类。 但是， 你不能忽视继承可能引发的几个严重问题。

- 子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为。

- 继承是静态的。 你**无法**在运行时**更改已有对象的行为**， 只能使用由不同子类创建的对象来替代当前的整个对象。

- 其中一种方法是用*聚合*或*组合* ， 而不是*继承*。 两者的工作方式几乎一模一样： 一个对象*包含*指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为， 它们自己*能够*完成这些工作。

  > 组合和聚合的核心就是：“把你本来想要继承的类，变成——包含指向另一个对象的引用”并将部分工作委派给引用对象

这个新方法来轻松替换各种连接的 “小帮手” 对象， 从而能在运行时改变容器的行为。 一个对象可以使用多个类的行为， 包含多个指向其他对象的引用， 并将各种工作委派给引用对象。 聚合 （或组合） 组合是许多设计模式背后的关键原则 （包括装饰在内）。 

![继承与聚合的对比](https://refactoringguru.cn/images/patterns/diagrams/decorator/solution1-zh.png)

*封装器*是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。  “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。

那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。

![装饰模式解决方案](https://refactoringguru.cn/images/patterns/diagrams/decorator/solution2-zh.png)

客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。

实际与客户端进行交互的对象将是最后一个进入栈中的装饰对象。 由于所有的装饰都实现了与通知基类相同的接口， 客户端的其他代码并不在意自己到底是与 “纯粹” 的通知器对象， 还是与装饰后的通知器对象进行交互。

我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。

![装饰模式示例](https://refactoringguru.cn/images/patterns/content/decorator/decorator-comic-1.png)

穿衣服是使用装饰的一个例子。 觉得冷时， 你可以穿一件毛衣。 如果穿毛衣还觉得冷， 你可以再套上一件夹克。 如果遇到下雨， 你还可以再穿一件雨衣。 所有这些衣物都 “扩展” 了你的基本行为， 但它们并不是你的一部分， 如果你不再需要某件衣物， 可以方便地随时脱掉。

### 装饰模式结构



![装饰设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-indexed.png)

###### （Component） 声明封装器和被封装对象的公用接口。

###### （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。

###### （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。

###### （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。

######  （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。



##### 装饰模式适合应用场景

 如果你希望在**无需修改代码的情况下即可使用对象**， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。

装饰能将业务逻辑组织为层次结构， 你**可为各层创建一个装饰**， 在运行时将各种不同逻辑组合成对象。 由于**这些对象都遵循通用接口**， 客户端代码能以相同的方式使用这些对象。

**如果用继承来扩展对象行为的方案难以实现或者根本不可行**， **你可以使用该模式**。

##### 实现方式

- **确保业务逻辑可用一个基本组件及多个额外可选层次表示。**

- **找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。**

- **创建一个具体组件类， 并定义其基础行为。**

- **创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。**

- **确保所有类实现组件接口。**

- **将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。**

- **客户端代码负责创建装饰并将其组合成客户端所需的形式。**

  

**装饰**是一种结构设计模式， 允许你通过将对象放入特殊封装对象中来为原对象增加新的行为。

由于目标对象和装饰器遵循同一接口， 因此你可用装饰来对对象进行无限次的封装。 结果对象将获得所有封装器叠加而来的行为。

##### 代码示例

```
package main
//零件接口
type pizza interface {
    getPrice() int
}


// 具体零件
type veggeMania struct {
}

func (p *veggeMania) getPrice() int {
    return 15
}

//具体装饰
type tomatoTopping struct {
    pizza pizza
}
func (c *tomatoTopping) getPrice() int {
    pizzaPrice := c.pizza.getPrice()
    return pizzaPrice + 7
}

//cheeseTopping.go: 具体装饰
type cheeseTopping struct {
    pizza pizza
}

func (c *cheeseTopping) getPrice() int {
    pizzaPrice := c.pizza.getPrice()
    return pizzaPrice + 10
}

```

```
//main.go: 客户端代码
package main

import "fmt"

func main() {

    pizza := &veggeMania{}

    //Add cheese topping
    pizzaWithCheese := &cheeseTopping{
        pizza: pizza,
    }

    //Add tomato topping
    pizzaWithCheeseAndTomato := &tomatoTopping{
        pizza: pizzaWithCheese,
    }

    fmt.Printf("Price of veggeMania with tomato and cheese topping is %d\n", pizzaWithCheeseAndTomato.getPrice())
}
```

- **原始类具有不变性**

### 2.Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法

《[函数式编程](https://coolshell.cn/articles/10822.html)》推荐阅读

```
def hello(fn):
    def wrapper():
        print "hello, %s" % fn.__name__
        fn()
        print "goodby, %s" % fn.__name__
    return wrapper

@hello
def foo():
    print "i am foo"

foo()
```

```
[chenaho@chenhao-air]$ python hello.py
hello, foo
i am foo
goodby, foo
```

你可以看到如下的东西：

1）函数foo前面有个@hello的“注解”，hello就是我们前面定义的函数hello

2）在hello函数中，其需要一个fn的参数（这就用来做回调的函数）

3）hello函数中返回了一个inner函数wrapper，这个wrapper函数回调了传进来的fn，并在回调前后加了两条语句。