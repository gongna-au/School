面向对象系统分析与设计

## 1.概述

## 1-1 概述

#### 1.1 分析与设计

|        **分析**        |   **设计**   |
| :--------------------: | :----------: |
|        用户视角        |  计算机视角  |
|        卖的视角        |   做的视角   |
|          具体          |     抽象     |
|      产品当项目做      | 项目当产品做 |
| 设计源于需求、高于需求 |              |

1. 什么是面向对象的分析？

   面向对象的分析强调的是在问题域内**发现和描述对象**。

2. 什么是面向对象的设计？

   面向对象的设计强调的是**如何定义对象**以及它们是**如何协作**的。

3. 什么是面向对象的分析与设计？

   分析是找到现实世界的对象，设计是找到软件世界的对象。

#### 1.2 面向对象

- **复用**

- 面向对象是什么？

  **对现实世界的理解和抽象出来的方法**

#### 1.3 UML建模

##### 1.建模过程

UML是一种很统一的、标准化的，应用面很广泛的建模语言。

**可以使用类图来指定和说明模型中的结构特性和使这些结构特性可视化。例如，在开发周期的分析和设计阶段，可以创建类图来执行下列功能**

> - 定义和捕获类及其他类元的结构
> - 定义类和类元之间的关系
> - 使用属性、操作和信号来说明模型的结构
> - 显示用来定义系统的行为的常见类元角色和职责
> - 显示包中的实现类
> - 显示一个或多个类的结构和行为
> - 显示类和类元之间的继承层次结构
> - 将工作程序和实体显示为业务对象模型

下图是一个简单类图的示例。此图说明用于表示购物车的类如何与用于表示顾客、购物清单和待售商品相关。<img src="https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/images/cclassd_a.gif" alt="一个简单类图" style="zoom:200%;" />

- **一个购物车**
  1. **属于某个顾客**
  2. **里面有很多商品，每个商品可以有自己的信息**
  3. 购物车是商品的集合，所以购物车有个属性就是购物清单。

- **[类](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cclss.html)**
  在 UML 中，一个类表示**一个对象**或者**共享同一结构和行为的一组对象**。在 UML 图中，类或类的实例是常见模型元素。

- **[对象](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cobj.html)**
  在 UML 模型中，对象是用来表示一个或多个**类**的**实例**的模型元素。可以将**对象添加至模型**来表示具体实例和典型实例。具体实例表示现实世界中实际的人或事。例如，Customer 类的具体实例表示实际的客户。Customer 类的典型实例包含用来表示典型客户的数据。

- **[包](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cpkg.html)**
  包用于将所有类型的相关模型元素（包括其他包）集中在一起。
- **[信号](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/csignal.html)**
  在 UML 模型中，信号是与用来处理信号的类元无关的模型元素。信号指定活动对象之间的单向异步通信。

- **[枚举](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cenum.html)**
  在 UML 模型中，枚举是类图中用来表示用户定义的数据类型的模型元素。枚举中包含多组用来表示枚举值的指定标识。这些值称为枚举字面值

- **[数据类型](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cdatatypes.html)**
  在 UML 图中，数据类型是用来定义数据值的模型元素。通常使用数据类型来表示基本类型（例如，Integer 或 String 类型）和枚举（例如，用户定义的数据类型）
- **[工件](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/cartifact.html)**
  在 UML 模型中，工件是用来表示软件系统中的物理实体的模型元素。工件表示物理实现单元，例如，可执行文件、库、软件组件、文档和数据库。

###### 创建类图

> 类图对一个包或整个系统的静态结构进行建模。

- 类图是系统的蓝图，可以使用类图来对组成系统的各个对象建模，从而允许您显示这些对象之间的关系以及描述这些对象执行的操作和提供的服务。

  - **[在图中指定关系](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/twrkrel.html)**
    在 UML 中，关系表示模型元素之间在语义上存在的联系。要对模型添加关系，您必须在图编辑器或者“项目资源管理器”视图中工作。

  - **[对关联添加限定符](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tqualassoc.html)**
    在 UML 模型中，可以对现有关联添加限定符，以对相关联元素之间的配对建立索引。

  - **[对建模图添加接口](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/taddint.html)**
    在 UML 建模中，可以对类图和组件图添加接口来指定接口与实现该接口的类元之间的合同。

  - **[管理类元中的属性和操作](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodattrop.html)**
    在 UML 图中，可以添加、删除、显示和隐藏类元中的属性和操作以及对它们进行排序，以确定它们的显示方式并定义它们所属类元的属性和行为。

  - **[设置模型元素的属性](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tpropover.html)**
    在类图中，可以设置模型元素的属性，以指定模型元素在类图中如何互相进行交互。

  - **[修改类元中的参数、字面值和信号](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodpls.html)**
    可使用类元中的参数、字面值和信号来指定图中模型元素的行为和属性。

  - **[修改模板参数和自变量](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodtpa.html)**
    在 UML 模型中，可通过将参数化类和协作绑定至模板来使用它们生成新的模型元素。创建的每个模板参数都使用一个类型（基本数据类型或模型元素类型）。当为参数化类或协作创建绑定关系时，可添加用于替换新生成元素中模板参数的自变量。

  - **[在图中指定关系](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/twrkrel.html)**
    在 UML 中，关系表示模型元素之间在语义上存在的联系。要对模型添加关系，您必须在图编辑器或者“项目资源管理器”视图中工作。

  - **[对关联添加限定符](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tqualassoc.html)**
    在 UML 模型中，可以对现有关联添加限定符，以对相关联元素之间的配对建立索引。

  - **[对建模图添加接口](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/taddint.html)**
    在 UML 建模中，可以对类图和组件图添加接口来指定接口与实现该接口的类元之间的合同。

  - **[管理类元中的属性和操作](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodattrop.html)**
    在 UML 图中，可以添加、删除、显示和隐藏类元中的属性和操作以及对它们进行排序，以确定它们的显示方式并定义它们所属类元的属性和行

  - **[设置模型元素的属性](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tpropover.html)**
    在类图中，可以设置模型元素的属性，以指定模型元素在类图中如何互相进行交互。

  - **[修改类元中的参数、字面值和信号](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodpls.html)**
    可使用类元中的参数、字面值和信号来指定图中模型元素的行为和属性。

  - **[修改模板参数和自变量](https://www.ibm.com/docs/zh/SS8PJ7_9.6.1/com.ibm.xtools.modeler.doc/topics/tmodtpa.html)**
    在 UML 模型中，可通过将参数化类和协作绑定至模板来使用它们生成新的模型元素。创建的每个模板参数都使用一个类型（基本数据类型或模型元素类型）。当为参数化类或协作创建绑定关系时，可添加用于替换新生成元素中模板参数的自变量。

    

###### 创建对象图

> ###### 在 UML 模型中，可通过将参数化类和协作绑定至模板来使用它们生成新的模型元素。创建的每个模板参数都使用一个类型（基本数据类型或模型元素类型）。当为参数化类或协作创建绑定关系时，可添加用于替换新生成元素中模板参数的自变量。

###### 创建时序图

> 在 UML 模型中，交互是用来表示一个或多个参与者之间的通信的行为。时序图是一种 UML 交互图，它对在参与者之间传递的消息（例如，对象和角色）以及控制和条件结构（例如，组合片段）进行建模。可以创建新的时序图，使用源元素来填充现有时序图以及对时序图添加生命线、消息和组合片段。

###### 创建通信图

> 在 UML 模型中，交互是用来表示一个或多个参与者之间的通信的行为。通信图是一种 UML 交互图，用来说明参与交互的对象之间的消息流。可以在通信图中添加和修改生命线、消息路径和消息。

###### 创建组合结构图

> 在 UML 模型中，组合结构图使用部件、端口和连接器来显示类元和协作的内部结构。可以使用组合结构图来以可视方式说明包含类元的组合部件以及定义各个部件之间的行为和通信。

###### 创建状态机图

> 可使用状态机图来说明类、协作、组件、节点、操作、用例或完整系统的行为。



1. 为什么使用UML建模？

   - 利用UML20%就可以为80%的问题建模
   - 一图胜过千言万语

2. UML建模过程

   - 定义用例
   - 定义领域模型
   - 定义交互图
   - 定义设计类图

3. **定义领域模型（OOA）**

   1. 领域模型并不是对软件对象的描述，它是真实世界领域中概念和想象可视化，又称为概念模型。

      - 为什么要做领域建模?

        面向对象分析，强调的是在问题域发现并描述概念，解决的问题是**做正确的事情**。面向对象设计，强调的是定义软件对象，解决的问题是**正确的做事情**。

        领域模型就是面向对象分析的主要产物，它表达了对现实问题的描述和抽象。

        <img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-2/82987418.jpg" alt="img" style="zoom:200%;" />

        - 如果不做设计直接实现，俗称走一步看一步。很大可能在开发过程中发现思维局限，开发进度推倒重来。
        - 如果不做分析直接设计，看起来没什么问题。遗憾的是，通过这种方式构造的代码，并没有和现实世界连接起来，当我们的软件和需求稍加修改，这份代码就可能变得异常混乱和难以维护。而通过领域建模的，自上而下的设计，可以保证代码实现的层次结构和模块划分是科学的、稳定的。
        - 举一个例子，在某电商系统的初期设计中，一个卖家账号只能开一个店铺，因此卖家和店铺的概念全部由卖家这一个模型来承载。所有店铺相关的模型（店铺红包、店铺评价等）全部与卖家模型做关联。这时，同一个模型拥有了两层业务含义，职责不明确。
        - 再举一个例子，在我做的电商供应链管理系统中，对于箱规的定义起初并没有**抽象出模型**。随着系统更深入的发展，我们发现在多个模型里都维护着箱规，包括商品、货品甚至补货模型里都有着箱规的定义。此时各领域如果没有明确的职责划分，造成同一个模型在多个系统同时维护，势必会带来混乱。

- **总结：**

  **各个领域要有明确的职责划分。不同的功能你要划分开。**

  **对于在不同领域操作的对象，你最好抽象出一个模型。**对这个模型进行单独的操作与维护，当某个对象被多个领域同时进行操作与维护时，势必会带来混乱。

  **领域建模可以降低软件和现实世界之间的差异，<u>用真实的业务概念划分职责</u>，目的是实现一个可以高效低成本维护的可持续发展的软件系统。**
  **从领域模型推导到系统实现是一套引导思考的方式，也是一套科学的开发流程。其核心目的在于提供了系统设计的“指导方针”。领域模型必须站在用户需求和业务发展的角度上，既可以用来同客户沟通验证需求，又可以避免模型因实现的考量而带偏（实现成本、遗留系统）。**

##### 2.如何进行领域建模？

###### 1.用例分析法

> 同样，领域建模的方法也有很多种。下面列出的是一些常见的方法。需要注意，领域建模是需要依赖大量经验和思考的，各种方法起到的都是引导思路的作用用例分析法

- 1.获取用例描述
  - 既然我们的领域模型指的是问题域模型，那么建模也一定要从问题域入手。那么问题域的知识如何表现出来呢，一个最常见的方式就是通过用例，也可以通过场景Scenario来分析——总之就是一段**格式化的需求文字描述**。
- 2.寻找概念类
  - 寻找概念类就是对获取的用例描述进行语言分析，**识别名词和名词短语**，将其作为候选的概念类。
  - 当然，需求描述中的名词不可能完全等价于概念类，自然语言中的同义词、多义词都需要在此处进行区分。还有很多名词可能只是概念类的属性，不过没关系，在这一步骤可以都提取出来，在第四步再区分出概念类和属性。

- 3.添加关联

  - 关联意味着两个模型之间存在语义联系，在用例中的表现通常为两个名词被动词连接起来。<img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-9/13933697.jpg" alt="img" style="zoom:200%;" />

  - **<u>并非所有动词关联的概念类都需要作为关联存在更重要的是我们需要判断，两个概念类的关系是否需要被记住：</u>**

    ​	**这句话的意思是说，不是一个名词1+动词+名词2。这个时候，你已经确定名词1作为一个概念类，那么你名词2就一定要作为一个概念类。名词2做不做为概念类取决于这个动词是不是我们要定义出的一个函数（或者说是一组操作。）也就是“两个概念类的关系是否需要被记住“**

    ​	**试想你是一个业务员，如果某两个概念类的实例之间的关系没有任何人知道，是否会阻碍业务的开展。如果答案是肯定的，那么说明这两个概念类存在关联。如果答案是否定的，那么建议不要加上关联（视情况，也要考虑逻辑上二者的关系是否“被记住”）。**

    **如果阻碍了业务的发展，你就加上关联，如果没有阻碍业务的发展，你就不要加上关联。**

    - **应该尽量避免加入大量关联**
    - **关联不代表数据流，也不代表系统调用关系**

- 4.添加属性
  - 对于上文抽取到的名词列表，我们需要区分概念类和属性（当然名词列表也会有无用的词语）。
  - 如何判断一个名词是否是属性？
    - 能完全通过基本数据类型（数字、文本、日期）表达的大多是属性
    - 如果一个名词只关联一个概念类，并且它自身没有属性，那么他就是另一个概念类的属性
  - **注意这里表达的依然是业务概念，外键ID不是属性**

- **5.模型精化**
  - 模型精化是可选的步骤，有时我们希望在领域模型中表达更多的信息，这时会利用一些新的手段来表达领域模型：包括泛化、组合、子域划分等
  - 领域模型可以使用UML的泛化和组合表达模型间的关系，他们表达的是概念类的”is-a”和”has-a”的关系，并不是实现的软件类的关系。然而，也一些方法论中并不建议使用这种方式来表达领域模型，因为这种精化的领域模型不利于和需求方沟通。
  - 子领域划分是常见的拆解领域的方式，通常来说我们会将更内聚的一组模型划分为一个子领域，形成更高一层的抽象。利于系统的表达和分工。

****

**重点来了！！！！**

**下面举个例子，内容来自《Object-Oriented Analysis from Textual Specifications》[9]论文，该文章讲述了如何通过自然语言分析来做面向对象分析(OOA)。**

> - **Vendors** may be **sales employees** or **companies**. **Sales employees** receive a **basic wage** and a **commission**, whereas **companies** only receive a **commission**. Each **order** corresponds to one **vendor** only, and each **vendor** has made at least one **order**, which is identified by an **order number**. One **basic wage** may be paid to several **sales employees**. The same **commission** may be paid to several **sales employees** and **companies**



**供应商**可能是**销售员工**或**公司**。销售员工获得**基本工资**和**佣金**，而公司只获得**佣金**。每个**订单**只对应一个**供应商**，每个供应商至少下过一个订单，订单号由**订单号**标识。一份基本工资可以支付给几名销售员工。可能会向多个销售员工和公司支付相同的佣金

```


        供应商——------------------|
        						 |
        |     		 |           |
    销售员工    	公司           |
     |		|       |            |
     |      |       |            |
     |获得   |获得    |            |
                				 |
     基本工资      佣金  ——————    |         
								 订单  
								 |
								 订单号 
```

<img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-23/53571931.jpg" alt="img" style="zoom:200%;" />

最后，为这些候选的概念类选择属性，在本例中，如果一个概念类只处于一个被动的关联关系中（如basic wage, commission, order number），那么它需要作为关联类的属性

<img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-23/37093781.jpg" alt="img" style="zoom:200%;" />

###### 2.DDD的方法

> Eric Evans的著作Domain-Driven Design领域驱动设计，简称DDD。DDD是一套软件开发方法论，用来解决复杂的现实问题。
>   DDD本身是一套完整、详尽的方法论，从如何需求沟通（构建领域知识），到高层设计（战略建模）、详细设计（战术建模），细致到代码的实现风格都给出了示例。本文无意也无力来详述DDD的所有知识，但是关于如何建模，DDD给出了很多思想可以借鉴。

需要再次强调的是，DDD的模型本质上是solution space的模型，然而DDD强调模型与实现绑定，因此这里指的“模型”，可以说是领域模型，也可以是系统模型。下面就是DDD建模的一般步骤：

- 构建领域知识
  - 软件的最终目的是增进一个特定的领域。为了达到这个目的，软件需要跟要它服务的领域”和谐相处”。所谓和谐相处，软件需要精确地反应领域概念和知识，以更好的适应变化。
  - 因此，软件开发者第一步也是最重要的一步就是理解领域知识。DDD鼓励开发者和领域专家工作在一起，通过交谈和提问，让开发者学习到领域知识，挖掘出领域的关键概念。

- 创建通用语言
  - 通用语言是领域专家和开发团队之间定义的标准的术语。目的是把领域知识更完善地传达到软件中。

- 团队在进行所有方式的沟通时（文字，演讲，图形）都需要采用这种一致的语言。
  - 通用语言需要映射到模型中，映射到代码里。做到通用语言的更改就是对模型的更改，也是对代码的更改。

创建实体

- 基于通用语言和领域知识，需要首先分辨出实体。
- 实体是领域中**需要唯一标识**的领域概念。如果两个实体所有状态都一样，但标识不一样，就是两个不同的实体。
- 实体同样需要属性来描述
- <img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-26/30864092.jpg" alt="img"  />

创建值对象

- 值对象是领域中不需要唯一标识的领域概念。
- 如果两份对象所有状态都一样，我们就认为是同一个值对象。值对象也可以理解为一组聚合的属性。例如地址信息，类目信息。

<img src="http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-26/73204689.jpg" alt="img"  />



- 创建聚合根
  - 聚合根是一个实体，将一组模型聚合在一起，与外部模型划分开来。这一组模型全部关联着聚合根，只有聚合根负责与外部访问。
  - 聚合根有助于保持领域模型关联的简化和生命周期的维护。
  - ![img](http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-26/67066354.jpg)

###### 3.四色建模法

 四色建模法源于《Java Modeling In Color With UML》[10]，它是一种模型的分析和设计方法，通过把所有模型分为四种类型，帮助模型做到清晰、可追溯。

![img](http://fyl-image.oss-cn-hangzhou.aliyuncs.com/18-3-26/27002750.jpg)

- 四色模型
  moment-interval（时标性原型）：时标性原型是建模的起点，它代表着我们需要记录的，某一时刻发生的事件。例如订单，行程，会议。
  - moment-interval（时标性原型）：时标性原型是建模的起点，它代表着我们需要记录的，某一时刻发生的事件。例如订单，行程，会议。
  - party, place, or thing（人-事-物原型）：一种有形的，**可唯一识别的实体。**可以是人、机构、地点、物品等。
  - role （角色原型）：**角色是party, place, or thing的一种参与方式。**例如，在一份雇佣关系中，某个人扮演者雇员的角色。那么这个人就是”party, place, or thing”，雇员就是”role”。
  - description（描述原型）：表示资料类型的资源，是一种类似目录条目的描述，用来对对象进行分类或标记，可以被其它原型反复使用。例如，一个商品的品牌、描述属性。

- 建模次序[11]
  - 首先以满足管理和运营的需要为前提，寻找需要追溯的事件。
  - 根据这些需要追溯，寻找足迹以及相应的**时标性原型**。
  - 寻找时标对象周围的**人-事-物**。
  - 从中抽象**角色**。
  - 把一些信息用**描述**对象补足。

# 从领域模型到系统模型

  提到模型，大多数人第一反应就是一个类或者对象，我这里指的系统模型就是这种概念

为了保证程序实现能够遵循领域模型的思想，为了让所有人对领域和职责的认知没有偏差，我**强烈建议每个领域模型都要有一个系统模型与之对应**，最好能完全一一对应（DDD就是这么做的），他们的命名和属性也尽可能保持一致，使用相同的术语。

 具体到系统模型的设计，就是面向对象设计的范畴了，这里可以使用各种各样的设计模式、GRASP、SOLID去设计和规划，本文就不在此展开。
  需要遵循的宗旨是，**领域模型的模型职责**、**子域边界划分**应该作为此处设计的指导原则，在实现中的每个模块不可以突破这些职责约束。



# 领域模型与系统架构

  既然谈到了架构，我们先看看什么是架构，下面是ISO/IEC/IEEE 42010对软件架构的定义[12]：

> fundamental concepts or properties of a system in its environment embodied in its elements, relationships, and in the principles of its design and evolution
>
> 系统在其环境中的基本概念或属性，体现在其元素、关系以及设计和演化的原则中

可以看到有三个要素，elements，relationships，principles：

- element就是系统的组成成分。
  - 但实际上，系统可拆解的角度非常之多，可以是应用部署结构（物理架构），可以是进程，可以是微服务，可以是系统模型……
  - 在本文所指的业务系统架构中，更倾向于element指的是一个个系统模块，**它囊括了若干系统模型，组成一个内聚的职责明确的模块**
  - 这些拆解方式有一个共同点，需要是**最高层次的分解**，因此需要粗粒度的，足够简单，让人容易理解。

- relationship是成分间的关系，可以是层次结构，依赖关系
- principle指的是架构中使用的设计约束，如分层结构、EJB

领域模型和系统架构是什么关系呢？领域模型应该作为架构设计的重要输入，通常来说，领域模型的粒度较细，不足以作为软件架构的element或者component来解释，但是进一步抽象，领域模型的子领域划分是很好的模块划分方式，领域划分可以直接应用于架构的模块职责划分上。

除了领域模型，系统架构还需要考虑其他几个重要因素：

- 前瞻性。前瞻性通常来源于业务发展规划、公司战略方向甚至大到社会发展趋势，领域模型来源于明确的产品设计方案，往往是得不到这些概念性输入的。系统架构设计的前瞻性直接影响到架构的稳定性，如果架构随着业务变化而震荡，那么对技术团队来说就是灾难。
- 性能和稳定性。非功能性需求往往不会在领域模型里体现，系统的实现中可能需要通过缓存，监控，一致性协议等满足非功能需求。
- 公用组件的抽取和沉淀。

# 一些感想

 一切的方法论，都需要基于一些理想化的假设，但是现实世界的复杂注定了没有一套方法论是万能的、完整的。现实世界中，往往是这样的：

- 产品经理给出的需求描述（用例）永远都不完整，必须要靠持续的沟通和思考来挖掘真实的需求。
- 不同的人对于领域建模的方法和现实需求的理解各有不同，对未来的前瞻性也不同，这就导致当建模出现分歧时，难以有标准来判断谁是“正确”的。

因此，领域建模的的确确十分依赖经验，并不同于纯粹的技术，更是个人综合能力的一种体现。

参考资料

[1] Larman C. Applying UML and patterns[J]. Pearson Schweiz Ag, 2004.
[2] Martin J, Odell J J. Object-Oriented Methods: A Foundation[J]. Object-oriented methods : a foundation, 1998, 222(2):3–11.
[3] Fowler M. Analysis Patterns: Reusable Object Models[M]. DBLP, 1997.
[4] Fowler M. Patterns of enterprise application architecture[M]. 中国电力出版社, 2004.
[5] Evans. Domain-Driven Design: Tacking Complexity In the Heart of Software[M]. 2004.
[6] Fairbanks G, Garlan D. Just Enough Software Architecture: A Risk-Driven Approach[J]. Crc Press, 2010.
[7] Booch G, Maksimchuk R, Engle M, et al. Object-oriented analysis and design with applications, third edition.[M]// Object-oriented analysis and design with applications /. Benjamin/Cummings Pub. Co. 1994:1275-1279.
[8] https://en.wikipedia.org/wiki/Object-oriented_analysis_and_design
[9] Moreno A M. Object-Oriented Analysis from Textual Specifications[C]// of 9 Th International Conference on Software Engineering and Knowledge Engineering. 1997:157.
[10] Coad P, Deluca J, Lefebvre E. Java Modeling in Color with UML[J]. 1999.
[11] [运用四色建模法进行领域分析](http://www.infoq.com/cn/articles/xh-four-color-modeling/)
[12] [Systems and software engineering — Architecture description](http://www.iso-architecture.org/42010/defining-architecture.html)



## 1-2 迭代、进化和敏捷

#### 2.1 软件过程

1. 什么是软件过程？

   软件过程定义了软件开发、部署和维护的步骤。

2. 软件过程本身就是软件，是一种由人构成的虚拟机执行的软件。

#### 2.2 迭代式开发

1. 瀑布式生命周期

   试图在编写代码之前定义所有的需求，以及详尽的时间表。

2. 迭代式的生命周期

   - 通过多次的迭代获得周期性的反馈，以这些反馈为驱动力，对系统进行不断的扩展和精化
   - 迭代式开发将软件开发过程分解为一系列小的，固定的周期项目，每个小项目称为一次迭代
   - 迭代的周期固定，一般为2-6周

3. 迭代式开发的优势

   - 能够较早地应对风险高的内容
   - 能够让人明确地看到进展
   - 能够较早地获得反馈，鼓励用户参与，靠近用户的需求
   - 控制复杂性

#### 2.3 统一过程（Unified Process, UP）

1. UP是迭代过程的一种，提出人Ivar Jacobsn
2. UP具有灵活性，可以应用于敏捷方法
3. 4个主要阶段
   - 初始
   - 细化
   - 构造
   - 移交

#### 2.4 敏捷方法

1. 敏捷开发
   - 进化式精进的计划
   - 需求和设计的短时间迭代
   - 简易，轻量，沟通
2. 敏捷宣言
   - 个体和交流
   - 工作的软件
   - 与客户协作
   - 积极响应变更
   - 过程和工具
   - 完善的文档
   - 合同谈判
   - 严格履行计划
3. 敏捷原则
   - 通过早期和持续交付满足客户
   - 欢迎变更需求
   - 以两周-两月为周期，频繁交付软件
   - 每天开发人员都要和业务人员交流合作
   - 依靠有干劲的个体推动项目的开发
   - 衡量进度的重要尺度是可运行的软件
   - 提倡开发和集成
4. 什么是敏捷建模？
   - 不对所有或大部分软件设计建模或应用UML
   - 尽可能使用最简单的软件
   - 不单独建模
   - 并行建模
   - 明白“任何模型都不准确”
   - 开发者为自己进行建模

## 1-3.敏捷开发

#### 3.1 敏捷开发原则

敏捷开发10原则？？？

#### 3.2 Srum

Scrum是一个敏捷的过程，使我们能够专注于在最短的时间内提供最高的业务价值。

## 2. 需求&用例

#### 2.1 需求

1. 什么是需求？

   需求是一套系统或者项目所要满足的能力和条件。

2. 需求类型

#### 2.2 用例

1. 参与者种类

   - 主要参与者
   - 辅助参与者
   - 幕后参与者

2. 用例定义

   - 站在用户角度定义软件系统的外部特征
   - 可表示为系统提供的某种服务或者行为
   - 把现实世界捕获下来的方法

3. 用例和需求的关系

   - 用例就是需求，需求不是用例？？？

4. 什么是用例图？

   - 一个用例模型由若干个用例描述，用例图是显示一组用例，参与者以及他们之间关系的图。

5. 用例图的组成

   - 一组用例
   - 一组参与者
   - 一组关系

6. 用例图的应用

   - 从用户角度来描述软件的需求
   - 分析产品的功能和行为
   - 定义和描述了系统的外部可见行为

7. 参与者

   - 定义：在系统之外，通过系统边界与系统进行直接有意义交互的任何事物。
   - 关键词：系统外、责任边界

8. 如何识别用例？

   1. 选择系统边界
   2. 确定主要参与者
   3. 确定每个主要参与者的目标
   4. 定义满足用户目标的用例，并根据其目标命名

9. 用例的粒度

   | 阶段                        | 粒度                                         | 例子                               |
   | :-------------------------- | :------------------------------------------- | :--------------------------------- |
   | 业务建模 （描述功能性需求） | 用例名称能够说明一个完整业务流程             | 取钱、报装电话、借书等             |
   | 概念建模                    | 用例描述一项完整业务的一个步骤               | 提供申请资料、受理业务等           |
   | 系统建模                    | 用例能够描述操作者与计算机的一次完整交互为宜 | 填写申请单、审核任务单、验证密码等 |

   **顺序是：一个业务，一个步骤，一次交互**

10. 用例描述

    描述用例的流程细节。

| **用例的不同部分**                                   | **注解**                             |
| :--------------------------------------------------- | :----------------------------------- |
| 用例名称 Use Case Name                               | 动词+名词                            |
| 范围 Scope                                           | 要设计的系统                         |
| 级别 Level                                           | “用户目标”或者是“子功能”             |
| 主要参与者 Primary Actor                             | 与系统交互完成服务                   |
| 涉众及观众点 Stakeholders and Interests              | 关注该用例的人及其需求               |
| 前置条件 Preconditions                               | 值得告诉读者，开始前必须为真的条件   |
| 成功保证 Success Guarantee                           | 值得告诉读者，成功完成必须满足的条件 |
| 主成功场景 Main Success Scenario                     | 典型的、无条件的、理想方式的成果场景 |
| 扩展 Extensions                                      | 成功或失败的替代场景                 |
| 特殊需求 Special Requirements                        | 相关的非功能需求                     |
| 技术和数据变元表 Technology and Data Variations List | 不同的I/O方法和数据格式              |
| 发生频率 Frequency of Occurrence                     | 影响对实现的调查、测试和时间安排     |
| 杂项 Miscellaneous                                   | 例如未决问题                         |

1. 用例描述四种形式
   - 命名
   - 摘要
   - 非正式
   - 详述
2. 用例描述组成
   - 用例名称
   - 范围
   - 级别
   - 主要参与者
   - 涉众及观众点
   - 前置条件
   - 成功保证
   - 主成功场景：基本事件流
   - 扩展
   - 后置条件
3. 用例描述举例

```
定时放票
范围：演唱会门票销售系统
级别：子功能
主要参与者：门票运营商
涉众及其关注点：
	门票运营商——准确的时间放票
前置条件：
	门票和价格已经定好
成功保证：
	运营商已经确定好票务信息准确以及时间代理准时触发事件
主成功场景：
	工作人员安排好放票时间
	时间到，时间代理触发提醒事件
	运营商收到提醒，开始放票
	余票学习成功的显示在电脑屏幕上
拓展：
	任何时间，系统崩溃
		工作人员重启系统
	购票量大响应缓慢
		运营商分时间放票
```

1. 用例描述总原则

   如果涉众不能理解和验证，就不是需求。（如果删除他，会不会有涉众的利益受到伤害）

2. 主成功场景编写要点

   - 只书写“可理解、可验证、可观测”的
   - 每个步骤一个句子
   - 使用主动语句，理清责任
   - 句子以参与者或者系统为主语

## 3 域模型与类图

#### 3.1 概念类

1. 概念类定义

   概念类是描述现实世界的实体或者概念，是现实世界问题域的概念。

2. 如何找到概念类

   - 重用或者修改现有模型
   - 使用分类列表
   - 确定名词短语，作为候选的关键抽象

#### 3.2 领域模型

1. 定义
   - 也称为域模型，概念模型，是对领域内的概念类或者对现实中对象的可视化表示。
   - 在UML中，领域模型被描述为一组没有定义操作的类图。
2. 领域模型不是数据模型，与概念数据模型类似

#### 3.3 关键抽象方法

从软件需求规格说明书或用例即用例描述中将所有名词抽取出来，填入“候选关键抽象表格”，从而识别出所有的关键抽象。

1. 候选的关键抽象表格由以下三列组成

   - 候选的关键抽象

   - 排除的原因，属性，同义词，无关类。

   - 选定的名词

     

2. CRC分析法(Class-Responsibility-Collaborator)

   - 是一种收集并整理卡片的开发方式

   - 是一种面向文本建模技术，具有影响力的敏捷思想

   - 步骤：

     选择一个候选的关键抽象

     确定一个与该候选关键抽象相关的的用例

     查看用例描述和系统的功能需求来确定职责和协作的关系

     用CRC卡片记录抽取出来的关键抽象

     基于以上的工作，更新候选关键抽象表格

3. 排除候选关键抽象的原因：

   - **的属性
   - 仅有一个实例
   - 系统外部的
   - 与**重复**
   - **可以和****合并

#### 3.4 类图

类图由以下元素组成：

![H24b08ad376864639bbbd347dc4e3a797o](https://bbkgl.github.io/cloud_img/H24b08ad376864639bbbd347dc4e3a797o.jpg)

1. 类的组成

   - 名字
   - 属性
   - 操作
   - 可见性
     - 私有
     - 公有

2. 关联

   关联是类之间的关系，表示有意义和值得关注的连接。

3. 为什么应该避免加入大量关联？

   - 节点间可以有(n * n * (n - 1) / 2)个关联？
   - 太多关联会导致混乱
   - 重点关注需要被记住的关联

4. 关联的多重性

   - 1个A的实例与**多少个**B的实例关联
   - 1个B的实例与**多少个**A的实例关联

## 4 交互图

#### 4.1 交互图概述

1. 顺序图，按照时间顺序来描述对象的交互
2. 通信图，围绕着对象和对象之间的链接来描述对象的交互

#### 4.2 顺序图

1. 定义：显示一组对象为了实现某种功能，而彼此发送和接收一串消息，这组对象可能是类，接口，节点等或者是具体的实例。
2. 建模元素
   - 对象
   - 生命线
   - 消息
   - 执行规格条

#### 4.3 系统顺序图

#### 4.4 通信图

1. 定义

   关注对象在参与具体的交互时，对象之间如何链接以及传递什么消息。

2. 3个元素

   - 对象
   - 链
   - 消息

#### 4.5 鲁棒图

鲁棒图的对象元素、职责、与MVC架构的元素对应关系

| **鲁棒图的元素** | **职责** | **组成架构的元素** | **MVC架构的元素** |
| :--------------- | :------- | :----------------- | :---------------- |
| 边界对象         | 交互     | 连接元素           | 视图              |
| 控制对象         | 控制     | 处理元素           | 控制器            |
| 实体对象         | 信息     | 数据元素           | 模型              |

鲁棒图建图原则

- 参与者只能与边界交谈
- 边界对象只能与控制体和参与者交流
- 实体对象也能与控制体交流
- 控制体可以和实体对象和边界对象交流，但接触不到参与者

## 5 用例关系和类图

#### 5.1 识别用例关系

1. 用例关系

   - 包含
   - 扩展
   - 泛化

2. 扩展关系VS包含关系

   | **包含关系**               | **扩展关系**                   |
   | :------------------------- | :----------------------------- |
   | 标示«include»的带箭头虚线  | 标示«extend»的带箭头虚线       |
   | 基础用例指向被包含的小用例 | 小用例指向被扩充的基础用例     |
   | 一定要执行小用例           | 条件成立（扩展点）才执行小用例 |

#### 5.2 类图

常用类图表示![H77071d77f8ee4293a32ddf566cacb972w](https://bbkgl.github.io/cloud_img/H77071d77f8ee4293a32ddf566cacb972w.png)

1. 依赖关系（虚线+开口箭头）VS关联关系（实线+开口箭头）

   - 从时间角度区分：依赖关系是一种短暂，动态的关系；关联关系是一种持久，静态的关系；
   - 从类之间关系的强弱区分：关联关系比较强；依赖关系弱；
   - 设计类之间关系需要遵循的原则：首先判断是不是“关联”关系，再判断是不是“依赖”关系
   - 依赖关系是单向的，关联关系之间的导航一般是双向的，关联关系体现在代码中一般是成员变量

2. 泛化关系（实线+空心闭合箭头）：一般类与具体类之间的关系（继承）

3. 接口（表示为空心圆圈）与实现（实现类虚线+空心闭合箭头指向接口）

4. 保护等级

   ![H65f3a9a87e154d3da29d41d67a614b75A](https://bbkgl.github.io/cloud_img/H65f3a9a87e154d3da29d41d67a614b75A.jpg)



## 6 面向对象

![H9c6ffe21e1f949919f802745bdeac639q](https://bbkgl.github.io/cloud_img/H9c6ffe21e1f949919f802745bdeac639q.jpg)

#### 6.1 面向对象的设计原则

1. 什么是面向对象设计？
   - 找到软件对象
   - 分配职责，协调
2. 面向对象的设计原则有什么意义？
   - 是指导面向对象设计的基本思想
   - 评价面向对象设计的价值观体系
   - 设计模式的出发点和归宿
3. 设计目标
   - 可扩展性
   - 灵活性
   - 健壮性
   - 可插入性
4. 好的设计
   - 容易理解
   - 容易修改和扩展
   - 容易复用
   - 容易实现和应用
   - 简单、紧凑，经济适用
5. 坏的设计
   - 僵化
   - 脆弱
   - 牢固
   - 粘滞
   - 不必要的复杂性
   - 不必要的重复
   - 晦涩
6. 设计原则
   - LSP：Liskov替换原则，子类对象必须可以替换基类对象
   - Meyer原则
   - OCP原则：开放-封闭原则，软件实体是可拓展但不可修改的
   - SRP原则：单一职责原则，一个类仅有一个引起它变化的原因
   - ISP原则：接口隔离原则，客户不依赖用不到的接口，只提供所需要的接口
   - DIP原则：依赖倒置原则，高层不依赖低层，二者依赖于抽象；针对接口编程

> 面向对象设计原则
> 内容来自《敏捷开发：原则、模式与实例》
>
> SRP单一职责原则（Single Responsibility Principle）：
> 　　就一个类而言，应该仅有一个引起它变化的原因。
> OCP开放-封闭原则（Open Closure Principle）：
> 　　软件实体（类，模块，函数等）应该可以扩展的，但不可修改。
> LSPLiskov 替换原则（Liskov Substitution Principle）：
> 　　子类型必须能够替换它们的基类型
> DIP依赖倒置原则（Dependence Inversion Principle）：
> 　　抽象不应该依赖于细节，细节应该依赖于抽象。
> ISP接口隔离原则（Interface Segregation Principle）：
> 　　不应该强迫客户依赖与它们不用的方法。接口属于客户，不属于它所在的类层次结构。
> REP重用发布等价原则（Release Reuse Equivalency Principle）：
> 　　重用粒度就是发布粒度。
> CCP共同封闭原则（Common Closure Principle）：
> 　　包中 所有类应该对于同一类性质的变化应该是共同封闭的。一个变化若对包产生影响，则将对包中所有的类产生影响。而对其它的包不造成影响。
> CRP共同重用原则（Common Resue Principle）：
> 　　一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。
> ADP无环依赖原则（Acyclic Dependencies Principle）：
> 　　在包的依赖关系图中不允许存在环。
> SDP稳定依赖原则（Stable Dependencies Principle）：
> 　　易变化包不应该依赖稳定包。
> SＡP稳定抽象原则（Stable Abstract Principle）：
> 　　朝着抽象方向扩展。

- **SRP原则**

  每个变化就是类的一个职责。当需求发生变化时，对应的反映为职责的变化。如果一个类承担多个职责，那么引起类变化的原因就有多个，等于就把这些职责耦合化了。

  如下图Rectangle类两个方法draw()和area()。初一看认为都是属于Rectangle的，但是考虑到用途时就会发现，如果一个应用只是用到图形计算area()的话，GUI绘画draw()就是多余的；反之亦然。违反了SRP原则

![这里写图片描述](https://img-blog.csdn.net/20170208172644197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

　因此我们应该将不同职责分开来，这样对Geometry Rectangle的修改就不会影响到Rectangle的应用。

![这里写图片描述](https://img-blog.csdn.net/20170208173413117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

有人会说，万一这两种职责都需要用到呢？使用时岂不是麻烦。这是我们使用一种折中方法,使用接口实现解耦：

![这里写图片描述](https://img-blog.csdn.net/20170208174429301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- #### OCP原则

开放-封闭原则中开放是指对扩展开放，封闭是指不必对原有模块进行修改。也就是说，当需求发生变化时，我们只需要添加新的模块，而无需修改原有代码。
　　如下代码，已有Circle，Square。当我们需要添加一个新的图形时就会出行问题，涉及到shape，drawAllShape中修改。违反了OCP原则，修改了原有代码。因为添加新的Rectangle类导致shape，circle，Square等需要重新编译，部署。

![这里写图片描述](https://img-blog.csdn.net/20170208194909929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![这里写图片描述](https://img-blog.csdn.net/20170208194937085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

　遵循OCP原则，我们可以将其共同部分抽象化，将不同部分写在继承的子类中。

![这里写图片描述](https://img-blog.csdn.net/20170208195608870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

但是这只是**对一种变化封闭了**。当我们产生另一种变化，比如我们需要先画圆，再按顺序画其他图形这是，drawAllShape就不再是封闭的了。因此，在设计中，开发人员需要预测最可能的变化。但是如果事先设置许多吊钩，最后又没用到，会需要花很多精力去维护。最好办法是尽快开发，缩短迭代周期来刺激变化产生。如果只是对两个图形排序可以：
![这里写图片描述](https://img-blog.csdn.net/20170208201123896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](https://img-blog.csdn.net/20170208201144565?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](https://img-blog.csdn.net/20170208201246691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](https://img-blog.csdn.net/20170208201311175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **LSP原则**

**要求子类型能够替换基类型。如果不能替换，导致将子类型赋值给基指针时导致开发者错误以为该指针指的是基类，错误使用基类中有，而子类中没有的方法，导致错误**

- **DIP原则**

　　依赖倒置原则：高层模块不依赖底层模块，二者依赖抽象；抽象不依赖细节，细节依赖抽象。如果高层依赖底层，导致底层的修改影响到高层，这是不应该的。高层属于业务逻辑层。而且由于依赖底层，导致高层重用比较困难。

- **也就是说：“所有的依赖关系都应该终止于抽象类或者接口“**

- **任何变量都不应该持有一个指向具体类的指针或者引用。**

**我们在应用程序中编写的大多数的具体的类是不稳定的，我们不想直接依赖这些不稳定的具体的类。通过把他们隐藏在抽象接口的后面，可以隔离他们的不稳定性。**![这里写图片描述](https://img-blog.csdn.net/20170208205724446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**上图的依赖违反DIP原则。我们可以通过抽象化将高层独立出来，翻转依赖关系如下图：**![这里写图片描述](https://img-blog.csdn.net/20170208205850977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **ISP原则**

  **在使用过程中有时候为了达到某种目的，过分使用接口继承，从而![这里写图片描述](https://img-blog.csdn.net/20170208211400170?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)为了满足一个子类型的功能而导致其他子类产生接口污染。**

一种方法是通过委托分离接口：
当TimedDoor需要注册一个超时请求时，新建一个Timer和DoorTimerAdapter对象，委托DoorTimerAdapter对象，并将DoorTimerAdapter对象注册到Timer中，当Timer对象发送timeout()消![这里写图片描述](https://img-blog.csdn.net/20170208212504904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)息给DoorTimerAdapter对象时，DoorTimerAdapter对象再把消息发给TimedDoor。

另一种使用多重继承：

![这里写图片描述](https://img-blog.csdn.net/20170208213015740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

　　认识五大原则后，我们发现前三个原则（SRP，OCP，LSP）针对的是某一个责任类的设计；而后两个原则（DIP，ISP）则是针对不同责任类之间的依赖关系。![这里写图片描述](https://img-blog.csdn.net/20170208214814014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTYyMzQ2MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



> 单一职责问题的由来:
>
> 类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障
>
> 单一职责原则是什么:
>
> 不要存在多于一个导致类变更的原因
>
> 遵循单一职责原则：
>
> 分别建立两个类 T1、T2，使 T1 完成职责 P1 功能，T2 完成职责 P2 功能。这样，当修改类T1 时，不会使职责 P2 发生故障风险；同理，当修改 T2 时，也不会使职责 P1 发生故障风险
>
> 但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？
>
> 因为有职责扩散。所谓职责扩散，就是因为某种原因，职责 P 被分化为粒度更细的职责 P1 和 P2。
>
> 比如：类 T 只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责 P 细分为粒度更细的职责 P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类 T1 和 T2，分别负责 P1、P2 两个职责.
>
> 但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类 T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）
>
> ## 单一职责原则举例
>
> 用一个类描述动物呼吸这个场景：
>
> ```
> class Animal {
>     func breathe(animal: String) {
>         print("\(animal)呼吸空气")
>     }
> }
> 
> let animal = Animal()
> animal.breathe(animal: "牛")
> animal.breathe(animal: "羊")
> animal.breathe(animal: "猪")
> 牛呼吸空气
> 羊呼吸空气
> 猪呼吸空气
> 
> ```
>
> 程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将 Animal 类细分为陆生动物类 Terrestrial，水生动物 Aquatic，代码如
>
> 
>
> ```
> class Terrestrial {
>     func breathe(animal: String) {
>         print("\(animal)呼吸空气")
>     }
> }
> 
> class Aquatic {
>     func breathe(animal: String) {
>         print("\(animal)呼吸水")
>     }
> }
> 
> let terrestrial = Terrestrial()
> terrestrial.breathe(animal: "牛")
> terrestrial.breathe(animal: "羊")
> terrestrial.breathe(animal: "猪")
> 
> let aquatic = Aquatic()
> aquatic.breathe(animal: "鱼")
> 牛呼吸空气
> 羊呼吸空气
> 猪呼吸空气
> 鱼呼吸水
> ```

> 我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改调用方。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：
>
> ```
> class Animal {
>     func breathe(animal: String) {
>         if (animal == "鱼") {
>             print("\(animal)呼吸水")
>         } else {
>             print("\(animal)呼吸空气")
>         }
>     }
> }
> 
> let animal = Animal()
> animal.breathe(animal: "牛")
> animal.breathe(animal: "羊")
> animal.breathe(animal: "猪")
> animal.breathe(animal: "鱼")
> ```
>
> 可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用 “猪” “牛” “羊” 等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：
>
> ```
> class Animal {
>     func breathe(animal: String) {
>         print("\(animal)呼吸空气")
>     }
> 
>     func breathe2(animal: String) {
>         print("\(animal)呼吸水")
>     }
> }
> 
> let animal = Animal()
> animal.breathe(animal: "牛")
> animal.breathe(animal: "羊")
> animal.breathe(animal: "猪")
> animal.breathe2(animal: "鱼")
> ```
>
> 可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。结论是：**只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；**
>
> 无论是在代码级别上违反单一职责原则，还是在方法级别上违反。
>
> **开闭原则**（Open Close Principle，OCP）是面向对象[设计原则](https://geek-docs.com/design-pattern/design-principle/design-principle-index.html)的一种，开闭原则也是面向对象的可复用设计的基石。开闭原则是指一个软件实体，如类、模块和函数应该对扩展开放,对修改关闭，也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化
>
> ## 开闭原则问题由来
>
> 在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
>
> ## 开闭原则是什么
>
> 开闭原则（Open Closed Principle，OCP）由勃兰特・梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。
>
> 开闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。
>
> 这个原则有两个特性:
>
> - 一个是说对于扩展是开放的
>
> - 一个是说对于更改是封闭的
>
>   面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是“开放-封闭原则”的精神所在。
>
> 比如，刚开始需求只是写加法程序，很快在client类中完成后，此时变化没有发生，需求让再添加一个减法功能，此时会发现增加功能需要修改原来这个类，这就违背了开放-封闭原则，于是你就应该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承、动态等来隔离具体加法、减法与client耦合，需求依然可以满足，还能应对变化。此时需求要添加乘除法功能，就不需要再去更改client及加减法类，而是增加乘法和除法子类即可。
>
> 绝对的修改关闭是不可能的，无论模块是多么的`封闭`，都会存在一些无法对之封闭的变化，既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先**猜测出最有可能发生的变化种类，**然后**构造抽象**来**隔离那些变化**。在我们最初编写代码时，假设变化不会发生，当**变化发生时，我们就创建抽象来隔离以后发生同类的变化。**
>
> 我们希望的是在开发工作展开不久就知道可能发生的变化，查明可能发生的变化所等待的时候越长，要创建正确的抽象就越困难。开闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中**呈现出现频繁变化的那些部分做出抽象**，然而对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意，**拒绝不成熟的抽象和抽象本身一样重要**。开闭原则，可以保证以前代码的正确性，因为没有修改以前代码，所以可以保证开发人员专注于将设计放在新扩展的代码上。
>
> 简单的用一句经典的话来说：过去的事已成历史，是不可修改的，因为时光不可倒流，但现在或明天计划做什么，是可以自己决定(即扩展)的。
>
> ```
> public interface ICourse {
>     String getName();  // 获取课程名称
>     Double getPrice(); // 获取课程价格
>     Integer getType(); // 获取课程类型
> }
> 
> /**
>  * 英语课程接口实现
>  */
> public class EnglishCourse implements ICourse {
> 
>     private String name;
>     private Double price;
>     private Integer type;
> 
>     public EnglishCourse(String name, Double price, Integer type) {
>         this.name = name;
>         this.price = price;
>         this.type = type;
>     }
> 
>     @Override
>     public String getName() {
>         return null;
>     }
> 
>     @Override
>     public Double getPrice() {
>         return null;
>     }
> 
>     @Override
>     public Integer getType() {
>         return null;
>     }
> }
> 
> // 测试
> public class Main {
>     public static void main(String[] args) {
>         ICourse course = new EnglishCourse("小学英语", 199D, "Mr.Zhang");
>         System.out.println(
>                 "课程名字:"+course.getName() + " " +
>                 "课程价格:"+course.getPrice() + " " +
>                 "课程作者:"+course.getAuthor()
>         );
>     }
> }
> ```
>
> 项目上线，课程正常销售，但是我们产品需要做些活动来促进销售，比如：打折。那么问题来了：打折这一动作就是一个变化，而我们要做的就是拥抱变化，现在开始考虑如何解决这个问题，可以考虑下面三种方案：
>
> **修改接口**
>
> 在之前的课程接口中添加一个方法 getSalePrice() 专门用来获取打折后的价格；
>
> 如果这样修改就会产生两个问题，所以此方案否定
>
> - ICourse 接口不应该被经常修改，否则接口作为契约的作用就失去了
>
> - 并不是所有的课程都需要打折，加入还有语文课，数学课等都实现了这一接口，但是只有英语课打折，与实际业务不符
>
>   ```
>   public interface ICourse {
>   
>       // 获取课程名称
>       String getName();
>   
>       // 获取课程价格
>       Double getPrice();
>   
>       // 获取课程类型
>       String getAuthor();
>   
>       // 新增：打折接口
>       Double getSalePrice();
>   }
>   ```
>
>   **修改实现类**
>
>   在接口实现里直接修改 getPrice()方法，此方法会导致获取原价出问题；或添加获取打折的接口 getSalePrice()，这样就会导致获取价格的方法存在两个，所以这个方案也否定。
>
>   **通过扩展实现变化**
>
>   直接添加一个子类 SaleEnglishCourse ,重写 getPrice()方法，这个方案对源代码没有影响，符合开闭原则，所以是可执行的方案,代码如下，代码如下：
>
>   ```
>   public class SaleEnglishCourse extends EnglishCourse {
>   
>       public SaleEnglishCourse(String name, Double price, String author) {
>           super(name, price, author);
>       }
>   
>       @Override
>       public Double getPrice() {
>           return super.getPrice() * 0.85;
>       }
>   }
>   
>   ```

> **里氏替换原则**（Liskov Substitution Principle, LSP）是面向对象[设计原则](https://geek-docs.com/design-pattern/design-principle)的一种，也叫里氏代换原则。里氏替换原则是关于继承的一个原则，遵循里氏替换原则能够更好地发挥继承的作用，里氏替换原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。
>
> **里氏替换原则问题由来**
>
> 有一功能 P1，由类 A 完成。现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能 P1 与新功能 P2 组成。新功能 P 由类 A 的子类 B 来完成，则子类 B 在完成新功能 P2 的同时，有可能会导致原有功能 P1 发生故障。
>
> **里氏替换原则是什么**
>
> **里氏替换原则的官方定义**
>
> - 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型
> - 所有引用基类的地方必须能透明地使用其子类的对象
>
> **里氏替换原则解读**
>
> 下面我们来解读下里氏替换原则的定义。
>
> 里氏替换原则强调的是设计和实现要依赖于抽象而非具体；子类只能去扩展基类，而不是隐藏或者覆盖基类，它包含以下4层含义
>
> -  **子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法**
>
> 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，**父类中凡是已经实现好的方法（**相对于抽象方法而言），**实际上是在设定一系列的规范和契约**，**虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏**
>
> 举例
>
> ```
> public class C {
>     public int func(int a, int b){
>         return a+b;
>     }
> }
> 
> public class C1 extends C{
>     @Override
>     public int func(int a, int b) {
>         return a-b;
>     }
> }
> 
> public class Client{
>     public static void main(String[] args) {
>         C c = new C1();
>         System.out.println("2+1=" + c.func(2, 1));
>     }
> }
> ```
>
> 上面的运行结果明显是错误的。类C1继承C，后来需要增加新功能，类C1并没有新写一个方法，而是直接重写了父类C的func方法，违背里氏替换原则，引用父类的地方并不能透明的使用子类的对象，导致运行结果出错。
>
> - **子类可以有自己的个性**
>
> 在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。前面其实已经提到，当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法，所以对上面的代码加以更改，使其符合里氏替换原则，代码如下：
>
> ```
> public class C {
>     public int func(int a, int b){
>         return a+b;
>     }
> }
> 
> public class C1 extends C{
>     public int func2(int a, int b) {
>         return a-b;
>     }
> }
> 
> public class Client{
>     public static void main(String[] args) {
>         C1 c = new C1();
>         System.out.println("2-1=" + c.func2(2, 1));
>     }
> }
> ```
>
> - **覆盖或实现父类的方法时输入参数可以被放大**
>
>   ```
>   public class ParentClazz {
>       public void say(CharSequence str) {
>           System.out.println("parent execute say " + str);
>       }
>   }
>   
>   public class ChildClazz extends ParentClazz {
>       public void say(String str) {
>           System.out.println("child execute say " + str);
>       }
>   }
>   
>   /**
>    * 测试
>    */
>   public class Main {
>       public static void main(String[] args) {
>           ArrayList list = new ArrayList();
>           ParentClazz parent = new ParentClazz();
>           parent.say("hello");
>           ChildClazz child = new ChildClazz();
>           child.say("hello");
>   
>       }
>   }
>   执行结果：
>   parent execute say hello
>   child execute say hello
>   ```
>
>   以上代码中我们并没有重写父类的方法，只是重载了同名方法，具体的区别是：子类的参数 String 实现了父类的参数 CharSequence
>
>   此时执行了子类方法，在实际开发中，通常这不是我们希望的，父类一般是抽象类，子类才是具体的实现类，如果在方法调用时传递一个实现的子类可能就会产生非预期的结果，引起逻辑错误，根据里氏替换的子类的输入参数要宽于或者等于父类的输入参数，我们可以修改父类参数为String，子类采用更宽松的 CharSequence，**如果你想让子类的方法运行，就必须覆写父类的方法**。代码如下：
>
>   ```
>   public class ParentClazz {
>       public void say(String str) {
>           System.out.println("parent execute say " + str);
>       }
>   }
>   
>   public class ChildClazz extends ParentClazz {
>       public void say(CharSequence str) {
>           System.out.println("child execute say " + str);
>       }
>   }
>   
>   public class Main {
>       public static void main(String[] args) {
>           ParentClazz parent = new ParentClazz();
>           parent.say("hello");
>           ChildClazz child = new ChildClazz();
>           child.say("hello");
>       }
>   }
>   
>   执行结果：
>   parent execute say hello
>   parent execute say hello
>   ```
>
> - 覆写或实现父类的方法时输出结果可以被缩小
>
>   当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格
>
> ```
> public abstract class Father {
>     public abstract Map hello();
> }
> 
> public class Son extends Father {
>     @Override
>     public Map hello() {
>         HashMap map = new HashMap();
>         System.out.println("son execute");
>         return map;
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         Father father = new Son();
>         father.hello();
>     }
> }
> 
> 执行结果：
> son execute
> ```
>
> - **里氏替换原则优点**
>
>   ```
>   保证了父类的复用性，同时也能够降低系统出错误的故障，防止误操作，同时也不会破坏继承的机制，这样继承才显得更有意义。
>   
>   增强程序的健壮性,版本升级是也可以保持非常好的兼容性.即使增加子类,原有的子类还可以继续运行.
>   
>   在实际项目中,每个子类对应不同的业务含义,使用父类作为参数,传递不同的子类完成不同的业务逻辑,完美!
>   ```
>
>   **总结：**
>
>   继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性。
>
>   如果一个类被其他的类所继承，那么这个类需要修改时，得考虑到所有的子类，如果父类被修改后，所有涉及到的子类的功能都有可能发生故障。
>
> **迪米特原则LoD**
>
> **迪米特原则问题由来**：
>
> 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
>
> **迪米特原则是什么：**
>
> - 一个对象应该对其他对象保持最少的了解
>
> 迪米特原则目的是尽量降低类与类之间的耦合。
>
> 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特原则要去完成的。
>
> 迪米特原则通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于**被依赖的类**来说，**无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息**
>
> **迪米特原则示例：**
>
> 通过老师要求班长告知班级人数为例，讲解迪米特原则。先来看一下违反迪米特法则的设计，代码如下
>
> ```
> public class Student {
>     private Integer id;
>     private String name;
> 
>     public Student(Integer id, String name) {
>         this.id = id;
>         this.name = name;
>     }
> }
> 
> public class Teacher {
>     public void call(Monitor monitor) {
>         List<Student> sts = new ArrayList<>();
>         for (int i = 0; i < 10; i++) {
>             sts.add(new Student(i + 1, "name" + i));
>         }
>         monitor.getSize(sts);
>     }
> }
> 
> public class Monitor {
>     public void getSize(List list) {
>         System.out.println("班级人数:" + list.size());
>     }
> }
> 
> ```
>
> 上面这个设计的主要问题出在 Teacher 中，迪米特原则要求只与直接的朋友发生通信，而 Student 类并不是 Teacher 类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲 Teacher 只与 Monitor 耦合就行了，与 Student 并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特原则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:
>
> ```
> public class Student {
>     private Integer id;
>     private String name;
> 
>     public Student(Integer id, String name) {
>         this.id = id;
>         this.name = name;
>     }
> }
> 
> public class Teacher {
>     public void call(Monitor monitor) {
>         monitor.getSize();
>     }
> }
> 
> public class Monitor {
>     public void getSize() {
>         List<Student> sts = new ArrayList<>();
>         for (int i = 0; i < 10; i++) {
>             sts.add(new Student(i + 1, "name" + i));
>         }
>         System.out.println("班级人数" + sts.size());
>     }
> }
> ```
>
> 将Student 从 Teacher 抽掉，也就达到了 Student 和 Teacher 的解耦，从而符合了迪米特原则。
>
> 迪米特原则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，老师(Teacher)就是通过班长(Monitor)这个“中介”来与 学生(Student)发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。
>
> **接口分离原则ISP**
>
> **接口分离原则**（Interface Segregation PrincipleISP）是面向对象[设计原则](https://geek-docs.com/design-pattern/design-principle)的一种，也叫接口隔离原则。接口分离原则指在设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。即，**一个类要给多个客户使用，那么可以为每个客户创建一个接口，然后这个类实现所有的接口；而不要只创建一个接口，其中包含所有客户类需要的方法，然后这个类实现这个接口**。
>
> **接口分离原则问题引入**
>
> 类 A 通过接口 I 依赖类 B，类 C 通过接口 I 依赖类 D，如果接口 I 对于类 A 和类 B 来说不是最小接口，则类 B 和类 D 必须去实现他们不需要的方法。
>
> **接口分离原则是什么**
>
> - 定义一：客户端不应该依赖它不需要的接口
>
> - 定义二：类间的依赖关系应该建立在最小的接口上
>
>   也就是说一个类对另一个类的依赖应该建立在最小的接口上,通俗的讲就是需要什么就提供什么，不需要的就不要提供。
>
>   接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。
>
> **接口分离原则好处**
>
> - 高内聚，低耦合
> - 可读性高，易于维护
>
> 
>
> ![接口分离原则例子](https://img.geek-docs.com/design-pattern/design-priciple/isp-example-1.jpg)
>
> ```
> 上面这个图的意思是：类A依赖接口 I 中的方法1、方法2、方法3，类 B 是对类 A 依赖的实现。类 C 依赖接口 I 中的方法1、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口 I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：
> 
> ```
>
> ```
> protocol I {
>     func method1()
>     func method2()
>     func method3()
>     func method4()
>     func method5()
> }
> 
> class A {
>     func depend1(i: I) {
>         i.method1()
>     }
> 
>     func depend2(i: I) {
>         i.method2()
>     }
> 
>     func depend3(i: I) {
>         i.method3()
>     }
> }
> 
> class B : I {
>     func method1() {
>         print("类 B实现接口 I 的方法 1")
>     }
> 
>     func method2() {
>         print("类 B实现接口 I 的方法 2")
>     }
> 
>     func method3() {
>         print("类 B实现接口 I 的方法 3")
>     }
> 
>     func method4() {}
> 
>     func method5() {}
> }
> 
> class C {
>     func depend1(i: I) {
>         i.method1()
>     }
> 
>     func depend2(i: I) {
>         i.method4()
>     }
> 
>     func depend3(i: I) {
>         i.method5()
>     }
> }
> 
> class D : I {
>     func method1() {
>         print("类 D实现接口 I 的方法 1")
>     }
> 
>     func method2() {
> 
>     }
> 
>     func method3() {
> 
>     }
> 
>     func method4() {
>         print("类 D实现接口 I 的方法 4")
>     }
> 
>     func method5() {
>         print("类 D实现接口 I 的方法 5")
>     }
> 
> }
> 
> let a = A()
> a.depend1(i: B())
> a.depend2(i: B())
> a.depend3(i: B())
> 
> let c = C()
> c.depend1(i: D())
> c.depend2(i: D())
> c.depend3(i: D())
> ```
>
> 可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：
>
> ![接口分离原则例子](https://img.geek-docs.com/design-pattern/design-priciple/isp-example-2.jpg)
>
> ```
> protocol I1 {
>     func method1()
> }
> 
> protocol I2 {
>     func method2()
>     func method3()
> }
> 
> protocol I3 {
>     func method4()
>     func method5()
> }
> 
> class A {
>     func depend1(i: I1) {
>         i.method1()
>     }
> 
>     func depend2(i: I2) {
>         i.method2()
>     }
> 
>     func depend3(i: I2) {
>         i.method3()
>     }
> }
> class B: I1, I2 {
>     func method1() {
>         print("类 B实现接口 I1 的方法 1")
>     }
> 
>     func method2() {
>         print("类 B实现接口 I2 的方法 2")
>     }
> 
>     func method3() {
>         print("类 B实现接口 I2 的方法 3")
>     }
> }
> 
> class C {
>     func depend1(i: I1) {
>         i.method1()
>     }
> 
>     func depend2(i: I3) {
>         i.method4()
>     }
> 
>     func depend3(i: I3) {
>         i.method5()
>     }
> }
> 
> class D : I1, I3 {
>     func method1() {
>         print("类 D实现接口 I1 的方法 1")
>     }
> 
>     func method4() {
>         print("类 D实现接口 I3 的方法 4")
>     }
> 
>     func method5() {
>         print("类 D实现接口 I3 的方法 5")
>     }
> }
> ```
>
> 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
>
> 很多人会觉的接口隔离原则跟之前的[单一职责原则](https://geek-docs.com/design-pattern/design-principle/single-responsibility-principle.html)很相似，其实不然。
>
> - 单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离
>
>   
>
> - 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建
>
>   采用接口隔离原则对接口进行约束时，要注意以下几点：
>
>   - 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
>   - 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系
>   - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情
>
>   运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。
>
>   极

#### 6.2 设计模式

1. 设计模式的基本思想
   1. 松耦合
   2. 针对接口编程
   3. 继承、组合、委托、多态、参数化
2. GRASP：通用职责分配软件模式
   - 创建者
   - 信息专家
   - 低耦合
   - 控制器
   - 高内聚
     - 不要给一个类太多的职责
     - 不相关的职责和功能不要分给一个类
   - 纯虚构
   - 多态
   - 间接性
   - 防止变异：避免系统或对象内部的变化影响其他模块和元素。

## 7 GOF设计模式

#### 7.1 适配器模式

- 问题：如何解决接口不相容的问题，如何为具有不同接口的相似组件提供一个统一稳定的接口
- 解决方案：通过一个中间的适配器对象，使一个组件的原有接口变为另一个接口

#### 7.2 工厂模式

- 问题：谁有责任创建写特殊考虑的对象？比如说有复杂的创建逻辑，为了更好地内聚性而希望分离创建职责
- 解决方案：创建一个称为工厂的纯虚构对象来处理。

#### 7.3 单例模式

- 问题：如何使得一个类严格地只有一个实例？
- 解决方案：对类定义静态方法，返回实例。