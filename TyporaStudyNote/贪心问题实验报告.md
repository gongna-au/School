# 贪心问题实验报告

2020213760   龚娜

### 1.算法复杂度分析

- **该算法for循环的时间复杂度为O(n)。**

- **该算法使用数组来存储每一段的距离，所以空间复杂度为O(n)。**



```
#include<iostream>
using namespace std;

void GreedyProblem (int a[],int n,int k)
{
	int sum=0,num=0,i;        //初始化需要加油的次数是sum   num是一共加几次油
	for(i=0;i<=n;i++)
	{
		if(a[i]>k)
		{
			cout<<"No solution "<<endl<<endl;   
			return;                             
		}
	}
	for(i=0;i<=n;i++)
	{
		sum=sum+a[i];
		if(sum>k)
		{
			num++;
			sum=a[i];
		}
	}
	cout<<num<<endl;
}

int main()
{
	int n,k,a[255];
	cin>>n>>k;              //n是一共有多少个加油站 k是满油可以行使多少公里 
	for(int i=0;i<=n;i++)   //按基本情况 有n个加油站 就有n+1段路程要跑 就如同 1 2 3 一共有4个空位 也就是要跑的路程
		cin>>a[i];          //输入每一段的距离
	GreedyProblem(a,n,k);
	return 1;
}

```

## 2.过程

1. 暴力解法

   **遍历每一个加油站为起点的情况，时间复杂度为O(n^2)；**

2. **贪心解法**

   **汽车行驶过程中，应走到自己能走到并且离自己最远的那个加油站，在那个加油站加油后再按照同样的方法贪心**

3. 思路

   具体算法：
   先检测各加油站之间的距离，若发现其中有一个距离大于汽车加满油能跑的距离，则输出no solution。否则，对加油站间的距离进行逐个扫描，尽量选择往远处走

## 3.结论

- **贪心法：一意孤行；**
- **动态规划：三思而后行**
- **实际上，贪心算法与动态规划算法都要求问题具有最优子结构性质。对于具有大量重叠子问题的问题，应采用动态规划算法；对于需要做出贪心选择的问题，采用贪心算法**