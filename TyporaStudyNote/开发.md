# 开发

### 需求背景

准备这期内容时，我在读者中间征集过日常找不到软件工具的小需求，作为实战项目的选题。最后也没找到合适选题，这期先用我曾经遇到的需求做例子。后续大家想到什么需求，还是可以留言，也许就用在下一个项目上。

这个需求很简单：**排序**。源自我第一份工作时，开发之余偶尔帮项目做版本管理。VCS 用的 P4，所有手机型号的项目，在同一个代码库的同一棵源码树上，通过分支和特性开关区分型号。优点是，跨型号共性问题，只要在源头上修改一次，随着代码定期集成到各分支，都会修复，避免重复劳动和遗漏型号。缺点是，针对某些型号的修改，如果隔离没做好，会影响无关的型号。

送测和正式发布的编译，为避免引入不确定的提交，采用基线（base）+ 追加提交的方式。会选择一个经过验证的提交作为 base，到 base 为止的所有修改都参与编译；base 之后的提交，往往都不太确定，遇到必须包含的提交，就要添加到追加提交里，编译时会将这些提交当作补丁按顺序应用到代码上（相当于临时 cherrypick）。但这个顺序，不是提交顺序，而是填写顺序。假如提交 A 修复问题 1 同时引起问题 2，之后提交 B 对同一个地方做修改修复问题 2。那么填写时必须按照 A 到 B 的顺序，否则 B 的修改会被 A 覆盖，问题 2 将仍然存在。

每次编译之前，在内网公布 base，模块负责人根据 base 回复需要追加的提交，然后管理员就得到了一堆提交号。P4 的提交号是自增序列号，所以只要将它们升序排列，就能保证先后顺序。

交流大概是这样的：

```
管理员：本次编译，base 为 123456
驱动组：133297 修复兼容性问题
电源管理组：167834 修正功耗计算
图形组：123467 调整刷新缓存
系统组：145683 修改进程管理策略
......
```

管理员经过整理，得到了 `123467,133297,145683,167834` 作为编译的参数。提交少的时候，人工处理一下就完了。但如果因为某些原因无法提高 base，后续的补丁却源源不断，提交可能会积累到过百，这时人工确认就又累又容易出错了。于是我当时就写了一个命令行工具来处理这么一个简单的需求。

为什么不直接用 Excel 呢？首先是 Office 启动慢，特别在已经打开一系列开发工具的前提下；其次需要将提交录入，排序之后还得想办法导出，又增加了工作量。Linux 底下倒是有一个 `sort` 命令，但是当时我在用 Windows。对于这种简单的需求，自己开发不仅工作量不大，遇到需求有变化时还很容易按需调整。

当时还没接触 Go，用的 C 开发。现在当然要用 Go 来练习。

### 小目标

一开始不要设太高的期待，先让程序可以跑起来，这样才能基于运行的反馈，一步步改善程序。为此先把需求简化到最简：从标准输入获取提交号，排好序之后，输出到标准输出，用英文逗号隔开（格式要方便后续使用，P4 要求的格式就是用逗号隔开的提交号，你也可以根据自己的需要调整）。

假定把这个程序叫 `gosort` ，那么用起来大概是这样的：

```
> gosort 133297 167834 123467 145683
123467,133297,145683,167834
```

### 命令行参数

`gosort 133297 167834 123467 145683` 这一串，对命令行环境来说，是（带参数的）命令，会根据开头的命令，传递给名为 `gosort` 的程序；而对 `gosort` 程序来说，这一串则是命令行参数。**注意，命令（程序名）也是参数的一部分**

> 有些程序实现了多种功能，对外链接到不同文件名，会根据传进来的程序名称不同，执行不同的动作。最典型的例子是 `busybox` ，它以单一可执行文件，提供了一个包含超过两百个命令的 unix 工具集合，被称为嵌入式 Linux 的瑞士军刀。

不像其它 C 家族语言，Go 的命令行参数不是作为 `main` 函数的参数传递的，而是通过 `os` 包的 `Args` 变量获取。`os` 包初始化时会获取参数并储存在 `Args` 中，它是一个字符串切片 `[]string`。前面介绍过查询文档的方法，想了解更多可以自行到 pkg.go.dev 查询；标准库源码则在 Go 的安装目录的 `src` 目录下，按包名储存，另外大多数 IDE 都支持源码的跟踪跳转（一般的操作，是对着 `os.Args` 按 `Ctrl` + 鼠标左键）。

```
// 包声明、import 语句已省略，请自行补充
func main() {
    fmt.Println(os.Args)
}
```

```
# 先编译
> go build
# 后执行。程序名请替换成你自己的 module 名。Linux 下本地执行需要加 ./
> gosort 133297 167834 123467 145683
# 以下是输出，我们先不要纠结方括号
[gosort 133297 167834 123467 145683]

# 当然我们也可以直接 go run
> go run main.go 133297 167834 123467 145683
# go run 本质上是在临时目录编译后执行，所以输出的程序名里带有临时目录信息
[C:\Users\Jayce\AppData\Local\Temp\go-build065892054\b001\exe\main.exe 133297 167834 123467 145683]
```

### 改善

这里我们需要改善几个问题：

- 在这个程序里，程序名用不上，留在切片里还会参与后续的排序。
- `os.Args` 是第三方包的包级变量，尽量不要直接在上面排序。虽然命令行参数在这个程序里暂时没有别的用处，但直接修改公共变量仍是一个坏习惯。
- 方括号其实是输出切片内容时的格式，最终结果不需要方括号，要想办法去掉。
- 不仅要去掉切片的方括号，还要加上英文逗号。

```
func main() {
    // n 是除了程序名以外的参数数量
    // len() 是内置函数，获取集合（这里是切片）的大小
    n := len(os.Args) - 1
    // 创建一个大小为 n 的切片
    nums := make([]string, n)
    // copy() 也是内置函数，把除程序名以外的参数拷贝到新切片
    // [1:] 是从下标 1 开始重新切片，跳过下标 0（即程序名）
    // 重新切片返回的新切片，跟原切片指向同一个底层数组，修改会互相影响，重新切片后还是要拷贝
    copy(nums, os.Args[1:])
     // 把参数逐个输出，其中前面的参数后面跟逗号，最后一个参数后面跟换行
    for i := 0; i < n-1; i++ {
        fmt.Print(nums[i], ",")
    }
    fmt.Println(nums[n-1])
}


```

### 排序

多快好省地实现排序算法，本身也是学问。但这次我们不研究这个，直接使用 `sort` 包。

自定义类型想要排序，需要实现 `sort.Interface` 接口的一系列方法；基本类型则预先实现了对应的函数。对于 `string` 类型的升序排序，`sort` 包给我们提供了 `sort.Strings()` 。

另外，前面最后的输出代码，实现起来还是比较麻烦，而且存在一个 bug。借助字符串工具包里的 `strings.Join()` 函数，可以先拼接成目标字符串，再一口气输出，既简单又绕开了 bug：

```
// 这次不再详细注释，有疑问请习惯查文档，或者参与讨论
func main() {
    n := len(os.Args) - 1
    nums := make([]string, n)
    copy(nums, os.Args[1:])
    sort.Strings(nums)
    fmt.Println(strings.Join(nums, ","))
}
```

这时编译之后再执行程序，效果如下：

```
> gosort 133297 167834 123467 145683
123467,133297,145683,167834
```



## 准备知识

### 标志（flag）参数

我们在之前已经了解过命令行参数。在 `gosort` 程序中，就是通过命令行参数，输入需要排序的编号。

简单的命令行参数输入后变成了字符串切片，只有位置（下标）的差别，不方便传递复杂的参数。如果规定特定次序的参数表示特定的含义，不好记忆不说，还无法缺省（因为一旦缺省，次序就乱了）。而像 `gosort` 程序这样，普通参数（又叫位置参数）数量不确定，把特殊参数放到最后面也达不到缺省的效果。

我们需要 标志（flag）参数，通过在短横线（也就是减号 `-` ）后面加上参数名，构成一个标志，使得参数变得有名字，不再受限于顺序。使用效果类似这样：

```
# 假定 gosort 支持标志参数 -x

# 允许缺省，此时 -x 为默认值
# 123 456 789 为三个普通参数，是需要排序的编号，下同
gosort 123 456 789
# 如果 -x 是一个布尔参数，那么有 -x 表示 true
gosort -x 123 456 789
# 如果 -x 不是布尔型的参数，那么还要指定 -x 的值
# 可以使用等号
gosort -x=out.txt 123 456 789
# 也可以不用等号，紧接着的第一个参数被认为是指定的值
gosort -x out.txt 123 456 789
```

> 标志就是参数的名字，可以通过标志来指定参数，实现了指定参数的目的，当然通过	切片的下标我们也可以指定参数，但是规定特定的下标代表特定的含义，1.不好记忆。2.还无法缺省这正是普通参数的缺点所在：数量不确定，把特殊参数放到最后也达不到缺省的效果。



自己实现标志参数并不难，只需要检查每一个命令行参数，找出短横线开头的，然后根据类型决定要不要读下一个参数作为值；处理的同时，要把标志参数和位置参数分开，供后续使用。虽然不难，实现起来比较琐碎，一不小心会漏掉一些边界条件，需要耐心地去测试完善。

> 标志参数 ：就是一个横线—加上参数名：
>
> —x  使得参数有名字，不再受限于顺序。

```
// 注意 xFlag 不是 bool 而是 *bool（bool指针）
// 创建时的三个参数，分别是参数名，默认值和参数说明
var xFlag = flag.Bool("x", flase, "试用 flag 参数，默认为 false")
// 解析需要放在所有 flag 设置好之后
flag.Parse()
// 需要解引用获取 bool 值
if *xFlag {
    // -x 设置为 true 时的操作
}
// 可以通过 flag 包访问位置参数的数量和值（去掉了程序名和标志参数)
fmt.Println("位置参数一共有", flag.NArg(), "个，分别是：", flag.Args())
```

除了直接生成标志参数后返回储存地址（指针），也可以声明好变量之后，在设置标志参数时指定储存的变量。

```
// 注意这里的 name 直接就是 string，不是指针
var name string
// 将 name 的地址传给标志参数
flag.StringVar(&name, "name", "无名", "试用 string 类型的 flag 参数")
// 解析时参数会储存到指定的变量
flag.Parse()
// name 本身就是 string，无需解引用
fmt.Println(name)
```

简单总结一下：

- `flag` 包保存着关于标志参数的全局状态， `flag.Parse()` 必须在 **所有标志参数设置好之后、访问任意一个参数值之前调用** 。
- `flag` 只支持基本类型 + `time.Duration` 类型的参数，每个类型有两个设置函数：不带 `Var` 结尾的直接返回储存变量的指针，带 `Var` 结尾的则需要你指定指针。
- 在使用时，标志参数必须位于所有位置参数之前，否则会被当做位置参数。例如 `gosort -x 123 456 -name bob` 无法得到 `name` 参数，反而会得到这样的位置参数： `["123","456","-name","bob"]` 。
- 标志参数名尽量避开 `h` 和 `help` ，因为 `flag` 包默认实现了这两个标志，打印帮助信息

> 记得标准库和第三方包的详细文档，可以在 pkg.go.dev 搜到。

> 在这一期里，部分函数只会做简略的介绍，详细的函数签名和用法需要大家自行看文档。

## 改进

在开始改进之前，先将之前的程序做一点小调整：把排序和拼接的代码，单独抽取成一个函数：

```
func main() {
    // 为了不修改包级变量（os.Args 以及后面的 flag.Args()）
    // 排序前先拷贝一份
    s := make([]string, len(os.Args)-1)
    copy(s, os.Args[1:]))
    fmt.Println(sortStrings(s))
}
// 因为不需要供包外调用，函数名小写开头即可
// 上一期介绍过函数签名和函数原型，读者想必可以看懂这个函数的参数和返回值
func sortStrings(strs []string) string {
    sort.Strings(strs)
    return strings.Join(strs, ",")
}
```

**将功能相对独立的、会被复用的代码抽取成函数是一个好的编程习惯，将函数内部控制在较少的容易理解的行数，可以让程序代码行数持续膨胀的同时，保持一个较好的可读性。**

### 按数值排序

还记得我们的需求吗？待排序的是一组提交编号，它们是单调递增的序列号。在实际使用中，因为代码库特别庞大，到后期提交编号达到好几位数，位数要过很长时间才增长一位，给人一种编号位数一直就是这么多的错觉。实际上并不是这样，编号用完了还是要进位的，9999 之后，就是 10000 了。

之前的实现按文本（字符串）排序，就出问题了。例如 `9,80,564,1253` 这几个数，如果按照数值排序，现在的顺序就是升序；可如果按字符串排序，则刚好反过来，顺序是 `1253,564,80,9` 。因为字符串是头部对齐后从左到右比较的，前缀分出先后就直接结束比较。

我们需要先将提交编号转换为数字，再按数字的规则排序。另一方面，按照字符串排序可以保留，让 `gosort` 程序有更多的用途，这时就需要一个标志参数区分开。现在规定默认情况按数值排序，而当设置 `-l` （lexically）时按字符串排序。

```
func main() {
    // 设置 bool 型的标志参数 -l
    var lex bool
    flag.BoolVar(&lex, "l", false, "sort lexically")
    flag.Parse()
    var res string
    if lex {
        // 如果设置了 -l，调用之前的sortStrings()
        // flag.Args() 返回的切片在 Parse() 的时候已经去掉了多余的参数
        s := make([]string, flag.NArg())
        copy(s, flag.Args())
        res = sortStrings(s)
    } else {
        // 否则先转为整型切片再排序
        // 由于没有对返回的切片进行修改，所以无需拷贝
        nums, err := strsToNums(flag.Args())
        // 命令行参数不一定都是数字，转换有可能失败，此时要打印错误信息并退出
        if err != nil {
            fmt.Println(err)
            // 0 以外的值表示异常退出
            // 退出后，后面的代码都不会再执行
            os.Exit(1)
        }
        res = sortNums(nums)
    }
    fmt.Println(res)
}
```

首先是设置标志参数并储存在变量 `lex` ，这部分内容参考前面的准备知识。然后程序根据 `lex` 的值执行不同的分支。如果是字符串排序，就是之前的函数。另外一个分支则多了几个新函数。

`strsToNums()` 是我们自己实现的函数，用来把字符串切片转换为整型数切片。因为转换有可能失败，所以返回值列表里还带着一个 `error` 类型的返回值。

```
func strsToNums(strs []string) ([]int, error) {
    // 创建同样大小的 int 切片，用来存放转换的结果
    nums := make([]int, len(strs))
    var err error
    // 遍历每个字符串并转换
    for i := range strs {
        nums[i], err = strconv.Atoi(strs[i])
        // 这里的逻辑是，只要其中一个字符串转换失败，就返回空白切片和错误
        // 你也可以改为忽略不能转换的字符串，继续转换和排序
        if err != nil {
            return nil, err
        }
    }
    return nums, nil
}
```

这里使用了标准库函数 `strconv.Atoi()` 。`strconv` 是 String Convert 的缩写，这个包里是跟字符串转换相关的工具函数，其中 `Atoi()` 就是把按十进制显示的字符串，转换为 `int` 型。因为字符串储存的不一定是十进制数，就有可能转换失败。

`sortNums()` 是另一个我们自己实现的函数，跟之前的 `sortStrings()` 类似。



```
func sortNums(nums []int) string {
    sort.Ints(nums)
    return numsJoin(nums)
}
```

由于整型切片无法直接 `strings.Join()` ，为了让 `sortNums()` 内部跟 `sortStrings()` 保持类似，我们又自行实现了 `numsJoin()`。把整型数拼接成逗号隔开的字符串有很多种具体的做法，这里是其中一种：

```
// 实现 1
func numsJoin(nums []int) string {
    // 一种直观的想法就是，再逐个转换回字符串，再 strings.Join()
    strs := make([]string, len(nums))
    for i := range nums {
        // 每个整型数都一定有对应的字符串表示，不存在失败，所以返回值里没有 error
        strs[i] = strconv.Itoa(nums[i])
    }
    return strings.Join(strs, ",")
}
```

不过我嫌这里做了两次转换（先从整型到一个个字符串，再把字符串拼成长字符串），有点浪费。能不能一步到位呢，于是我又写了第二种实现：

```
// 实现 2
func numsJoin(nums []int) string {
    // 声明一个 byte 切片作为缓冲区
    // 这里无需 make，因为后续的两个 append 操作都会根据需要扩展切片，包括 nil 切片也能处理
    var buf []byte
    for _, n := range nums {
        // 把转换后的字符串放进缓冲区（以字节的形式）
        strconv.AppendInt(buf, int64(n), 10)
        // 把逗号放进缓冲区
        append(buf, ',')
    }
    // byte 切片转换为字符串，只转换一次
    return string(buf)
}
```



> 这里需要补充说明一下：`string`与`[]byte`的转化（文本类型转换）
>
> #### 常规做法
>
> 通常`[]byte`和`string`可以直接通过类型名强制转化，但实质上执行了一次堆复制。理论上`stringHeader`只是比`sliceHeader`少一个`cap`字段，但因为`string`需要满足不可变的约束，而`[]byte`是可变的，因此在执行`[]byte`到`string`的操作时会进行一次复制，在堆上新分配一次内存。
>
> ```
> // byte to string
> s := string(b)
> 
> // string index -> byte
> s[i] = b
> 
> // []byte to string
> s := string(bytes)
> 
> // string to []byte
> bytes := []byte(s)
> ```
>
> ```
> 
> 黑魔法
> 利用unsafe.Pointer和reflect包可以实现很多禁忌的黑魔法，但这些操作对GC并不友好。最好不要尝试。
> 
> 
> 
> type Bytes []byte
> 
> // 将string转换为[]byte，'可以修改'，很危险，因为[]byte结构要多一个cap字段。
> func StringBytes(s string) Bytes {
>     return *(*Bytes)(unsafe.Pointer(&s))
> }
> 
> // 不拷贝地将[]byte转换为string
> func BytesString(b []byte) String {
>     // 因为[]byte的Header只比string的Header多一个Cap字段。可以直接强制成`*String` 
>     return *(*String)(unsafe.Pointer(&b))
> }
> 
> // 获取&s[0]，即存储字符串的字节数组的地址指针，Go里不允许这种操作。 
> func StringPointer(s string) unsafe.Pointer {
>     p := (*reflect.StringHeader)(unsafe.Pointer(&s))
>     return unsafe.Pointer(p.Data)
> }
> 
> // r获取&b[0]，即[]byte底层数组的地址指针，Go里不允许这种操作
> func BytesPointer(b []byte) unsafe.Pointer {
>     p := (*reflect.SliceHeader)(unsafe.Pointer(&b))
>     return unsafe.Pointer(p.Data)
> }
> ```
>
> 

我还能基于 `bytes.Buffer` 和 `strings.Builder` 写出别的实现版本。

但第一种实现就挺好的。这里只是展示，有时同一个功能可以有多种实现方式。开发的首要任务是实现功能，并且尽可能让代码易读，不容易出错。性能有时也重要，但必须是经过分析，确认有性能差异，并且这个差异对于程序的表现有影响。第二种实现一定比第一种性能好吗？差异是否大到值得特意去优化？使用看起来性能好但是不熟悉的实现，是否会带入潜在的 bug？答案都是不确定的。

这里为了行文方便，每个函数分开讨论，实际上它们都放在 `main.go` 里。在 Go 里，包级成员（包括函数）的引用顺序和声明顺序无关，只要不存在循环引用即可。一般的惯例是，`init()` 和 `main` （如果有）最前面，然后是导出（exported）成员（就是首字母大写那些），然后是未导出（unexported）成员。未导出函数之间，先被引用到的就放前面。

现在重新编译之后执行一下程序看看效果：

```
> gosort -h
Usage of gosort:
  -l    sort lexically
> gosort 1253 80 9 564
9,80,564,1253
> gosort 1253 abc 80 9 564
strconv.Atoi: parsing "abc": invalid syntax
> gosort -l 1253 abc 80 9 564
1253,564,80,9,abc
```

### 从文件输入输出

现在程序默认按数值排序，即使遇到长度不同的提交编号也不怕；同时按文本排序的功能也没丢掉，偶尔还能用来排一下人名之类的文本信息。程序够用了吗？

还是回到最初的需求。为什么不人工检查排序呢？因为编号多，最多达几十上百，这种数量，人工排序又慢又累又容易错。甚至不要说排序，就是把编号全部输入一遍，也是慢、累、易错。实际工作中都是打开记事本，把大家回复的编号整理起来，然后直接复制到命令行作为参数。有时还得追加提交编号，就把新的编号放到记事本最后面，然后 Ctrl + A（全选），Ctrl + C（复制），来到命令行，Ctrl + V（粘贴），熟练到麻木。

这时可以设置标志参数 `-f` （file，不过为了跟后面的输出区分，还是理解为 from 吧），传入一个文件，让程序改为从文件读入。这里假定文本文件里只有编号，以空白字符隔开。

```
func main() {
    // 省略 -l 部分代码...
    var from string
    flag.StringVar(&from, "-f", "", "input from file")
    flag.Parse()
    
    var strs []string
    if from != "" {
        // 如果不是文件，输出错误信息并退出
        if !isFile(from) {
            fmt.Println(from, " is not a file")
            os.Exit(1)
        }
        // 读取文件有多种实现方式，这里采用了最简单的 ioutil 包
        buf, err := ioutil.ReadFile(from)
        // 如果读取文件有错误，也是输出错误信息并退出
        if err != nil {
            fmt.Println("read ", from, " fail: ", err)
            os.Exit(1)
        }
        // 这里不要用 strings.Spilt(string(buf), " ")，因为间隔的空白字符可能不止一个
        // Fields() 以任意数量的空白字符作为分割
        strs = strings.Fields(string(buf))
    }
    // 无论是否从文件读入，位置参数都追加到后面
    // ... 的含义，请参考上一期可变参数部分
    strs = append(strs, flag.Args()...)
    var res string
    if lex {
        // 前面 append 时字符串追加到了新切片，这里不用再拷贝
        res = sortStrings(strs)
    } else {
        nums, err := strsToNums(strs)
    // 省略之后的代码...
}


```

增加了 `-f` 参数之后，如果 `from` 有值，而且这个值确实是一个有效的文件，就会从里面读取内容。位置参数的值同时也追加到切片里。

这里面用到的新函数，只有 `isFile()` 是自行实现，其它像 `ioutil.ReadFile()` 和 `strings.Fields()` 可以直接查询文档。

```
// 判断是否文件的固定套路
func isFile(path string) bool {
    info, err := os.Stat(path)
    if err != nil && !os.IsExist(err) {
        return false
    }
    return !info.IsDir()
}
```

