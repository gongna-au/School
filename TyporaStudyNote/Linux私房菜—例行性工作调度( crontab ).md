# Linux私房菜—例行性工作调度( crontab )

### 15.1 什么是例行性工作调度

> 每个人或多或少都有一些约会或者是工作,有的工作是例行性的, 例如每年一次的加薪、每个月一次的工作报告、每周一次的午餐会报、每天需要的打卡等等; 有的工作则是临时发生的,例如刚好总公司有高官来访,需要你准备演讲器材等等!

上面这些例行性工作,通常你得要记录在行事历上面才能避免忘记!不过,由于我们常常在计算机前面的缘故, 如果计算机系统能够主动的通知我们的话,那么不就轻松多了!这个时候 Linux 的例行性工作调度就可以派上场了

不考虑硬件与我们服务器的链接状态下,我们的 Linux 可以帮你提醒很多任务,例如:每一天早上 8:00 钟要服务器连接上音响,并启动音乐来唤你起床;而中午 12:00 希望 Linux可以发一封信到你的邮件信箱,提醒你可以去吃午餐了; 另外,在每年的你爱人生日的前一天,先发封信提醒你,以免忘记这么重要的一天。

**Linux 的例行性工作是如何进行调度的呢?所谓的调度就是将这些工作安排执行的流程之意**。

咱们的 Linux 调度就是通过 **crontab**与 **at** 这两个东西。

#### 15.1.1 Linux 工作调度的种类: at, cron

从上面的说明当中,我们可以很清楚的发现**两种工作调度的方式:**

- 一种是例行性的,就是每隔一定的周期要来办的事项;
- 一种是突发性的,就是这次做完以后就没有的那一种

那么在 Linux 下面如何达到这两个功能呢?那就得使用 **at 与 crontab** 这两个好东西

- at : at 是个可以**处理仅执行一次就结束调度的指令,**不过要执行 at 时, 必须要有 atd 这个服务 (第十七章) 的支持才行。在某些新版的 distributions 中, atd 可能默认并没有启动,那么 at 这个指令就会失效呢!不过我们的 CentOS 默认是启动的
- crontab : crontab 这个指令所设置的工作将会循环的一直进行下去! 可循环的时间为分钟、小时、每周、每月或每年等。 crontab 除了可以使用指令执行外,亦可编辑 /etc/crontab 来支持。 至于让 crontab 可以生效的服务则是 crond 这个服务喔

下面我们先来谈一谈 Linux 的系统到底在做什么事情,怎么有若干多的工作调度在进行呢?

#### 15.1.2 CentOS Linux 系统上常见的例行性工作

你大概会发现到 Linux 会主动的帮我们进行一些工作呢! 比方说自动的进行线上更新 ( on-line update )、自动的进行 updatedb (第六章谈到的 locate 指令) 更新文件名数据库、自动的作登录文件分析 (所以 root 常常会收到标题为logwatch 的信件) 等等。这是由于系统要正常运行的话, 某些在背景下面的工作必须要定时进行的缘故。基本上 Linux 系统常见的例行性任务有:

- 进行登录文件的轮替 ( log rotate )

  Linux 会主动的将系统所发生的各种信息都记录下来,这就是**登录文件** (第十八章)由于系统会一直记录登录信息,所以登录文件将会越来越大!我们知道大型文件不但占容量还会造成读写性能的困扰, 因此适时的将登录文件数据挪一挪,让旧的数据与新的数据分别存放,则比较可以有效的记录登录信息。这就是 **log rotate** 的任务!这也是系统必要的**例行任务**;

- 登录文件分析 logwatch 的任务:
  如果系统发生了软件问题、硬件错误、资安问题等,绝大部分的错误信息都会被记录到登录文件中, 因此系统管理员的重要任务之一就是分析登录文件。但你不可能手动通过 vim 等软件去检视登录文件,因为数据太复杂了! 我们的 CentOS 提供了一只程序 “ logwatch ” 来主动分析登录信息,所以你会发现,你的 root 老是会收到标题为 logwatch 的信件,那是正常的。

- 创建 locate 的数据库:

  指令是通过已经存在的文件名数据库来进行系统上文件名的查询。我们的文件名数据库是放置到 /var/lib/mlocate/ 中。 问题是,这个数据库怎么会自动更新啊?嘿嘿!这就是系统的例行性工作所产生的效果啦!系统会主动的进行updatedb !

- man page 查询数据库的创建

  与 locate 数据库类似的,可提供快速查询的 man page db 也是个数据库,但如果要使用 man page 数据库时,就得要执行 mandb 才能够创建好啊! 而这个 man page 数据库也是通过系统的例行性工作调度来自动执行的

- RPM 软件登录文件的创建:

  RPM (第二十二章) 是一种软件管理的机制。由于系统可能会常常变更软件, 包括软件的新安装、非经常性更新等,都会造成软件文件名的差异。为了方便未来追踪,系统也帮我们将文件名作个排序的记录。有时候系统也会通过调度来帮忙 RPM 数据库的重新创建。

- 移除暂存盘

  某些软件在运行中会产生一些暂存盘,但是当这个软件关闭时,这些暂存盘可能并不会主动的被移除。 有些暂存盘则有时间性,如果超过一段时间后,这个暂存盘就没有效用了,此时移除这些暂存盘就是一件重要的工作! 否则磁盘容量会被耗光。系统通过例行性工作调度执行名为 **tmpwatch 的指令**来删除这些暂存盘呢

- 与网络服务有关的分析行为

  如果你有安装类似 WWW 服务器软件 (一个名为 apache 的软件),那么你的 Linux 系统通常就会主动的分析该软件的登录文件。同时某些凭证与认证的网络信息是否过期的问题,我们的 Linux 系统也会很亲和的帮你进行自动检查。

**其实你的系统会进行的例行性工作与你安装的软件的多少有关。如果你安装了太多的软件，某些服务功能的软件都会附上分析工具。那么你的系统就会多出一些例行性工作。**

### 15.2 仅执行一次的工作调度

首先,我们先来谈谈单一工作调度的运行,那就是 at 这个指令的运行!

#### 15.2.1 atd 的启动与 at 运行的方式

要使用单一工作调度时,我们的 Linux 系统上面必须要有**负责这个调度的服务**,那就是 atd 这个玩意儿。所以呢,某些时刻我们必须要手动将他启用才行。 启用的方法很简单,就是这样:

```
[root@study ~]# systemctl restart atd # 重新启动 atd 这个服务
[root@study ~]# systemctl enable atd # 让这个服务开机就自动启动
[root@study ~]# systemctl status atd # 查阅一下 atd 目前的状态
atd.service - Job spooling tools
Loaded: loaded ( /usr/lib/systemd/system/atd.service; enabled )
# 是否开机启动
Active: active ( running ) since Thu 2015-07-30 19:21:21 CST; 23s ago # 是否正在运行中
Main PID: 26503 ( atd )
CGroup: /system.slice/atd.service
└─26503 /usr/sbin/atd -f
Jul 30 19:21:21 study.centos.vbird systemd[1]: Starting Job spooling tools...
Jul 30 19:21:21 study.centos.vbird systemd[1]: Started Job spooling tools.
```

**重点就是要看到上表中的特殊字体,包括 “ enabled ” 以及 “ running ” 时,这才是 atd 真的有在运行。**

- **at 的运行方式**

  所谓的工作调度就是：**产生工作的方式，以及把工作安排到进程表中。**那么我们的系统产生工作的方式是什么？这些方式又是怎么进行的？

  答：**是这样的。我们通过at这个指令产生所要运行的工作，并且把这个工作以文本文件的方式写入到/var/spool/at/ 目录内，然后该工作就可以等着atd这个服务的取用和执行。就是这么简单。**

  但是，并不是所有的人都可以进行 at 工作调度。为什么鸭？因为安全性呀~很多的主机被绑架的本质就是atd取用的服务中被加入了很多的工作（系
  统当中多了很多的怪客程序 ( cracker program )），这些**程序非常可能运用工作调度来执行或蒐集系统信息,并定时的回报给怪客团体**

所以,除非是你认可的帐号,否则先不要让他们使用 at 吧!那怎么达到**使用 at 的列管**呢?

我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制呢! 加上这两个文件后, at 的工作情况其实是这样的:

- 先找寻 /etc/at.allow 这个文件,写在这个文件中的使用者才能使用 at ,没有在这个文件中的使用者则不能使用 at (即使没有写在at.deny 当中);

- . 如果 /etc/at.allow 不存在,就寻找 /etc/at.deny 这个文件,若写在这个 at.deny 的使用者则不能使用 at ,而没有在这个 at.deny 文件中的使用者,就可以使用 at 咯;

- 如果两个文件都不存在,那么只有 root 可以使用 at 这个指令。

  通过这个说明,我们知道 /etc/at.allow 是管理较为严格的方式,而 /etc/at.deny 则较为松散 (因为帐号没有在该文件中,就能够执行 at了)。在一般的 distributions 当中,由于假设系统上的所有用户都是可信任的, 因此系统通常会保留一个空的 /etc/at.deny 文件,意思是允许所有人使用 at 指令的意思 (您可以自行检查一下该文件)。 不过,万一你不希望有某些使用者使用 at 的话,将那个使用者的帐号写入/etc/at.deny 即可! 一个帐号写一行。

#### 15.2.2 实际运行单一工作调度

单一工作调度的进行就使用 at 这个指令啰!这个指令的运行非常简单!将 at 加上一个时间即可!基本的语法如下:

```
[root@study ~]# at [-mldv] TIME
[root@study ~]# at -c 工作号码
选项与参数:
-m :当 at 的工作完成后,即使没有输出讯息,亦以 email 通知使用者该工作已完成。
-l :at -l 相当于 atq,列出目前系统上面的所有该使用者的 at 调度;
-d :at -d 相当于 atrm ,可以取消一个在 at 调度中的工作;
-v :可以使用较明显的时间格式列出 at 调度中的工作列表;
-c :可以列出后面接的该项工作的实际指令内容。
TIME:时间格式,这里可以定义出“什么时候要进行 at 这项工作”的时间,格式有:
HH:MM
ex> 04:00
在今日的 HH:MM 时刻进行,若该时刻已超过,则明天的 HH:MM 进行此工作。
HH:MM YYYY-MM-DD ex> 04:00 2015-07-30
强制规定在某年某月的某一天的特殊时刻进行该工作!
HH:MM[am|pm] [Month] [Date] ex> 04pm July 30
也是一样,强制在某年某月某日的某时刻进行!
HH:MM[am|pm] + number [minutes|hours|days|weeks]
ex> now + 5 minutes ex> 04pm + 3 days
就是说,在某个时间点“再加几个时间后”才进行。
```

老实说,这个 at 指令的下达最重要的地方在于 “ 时间 ” 的指定了!喜欢使用 “ now + ... ” 的方式来定义现在过多少时间再进行工作,但有时也需要定义特定的时间点来进行!下面的范例先看看

```
[root@study ~]# at now + 5 minutes <==记得单位要加 s 喔!
at> /bin/mail -s "testing at job" root < /root/.bashrc
at> <EOT> <==这里输入 [ctrl] + d 就会出现 <EOF> 的字样!代表结束!
job 2 at Thu Jul 30 19:35:00 2015
范例一:再过五分钟后,将
# 上面这行信息在说明,第 2 个 at 工作将在 2015/07/30 的 19:35 进行!
# 而执行 at 会进入所谓的 at shell 环境,让你下达多重指令等待运行!
2 项工作内容列出来查阅
[root@study ~]# at -c 2
#!/bin/sh
<==就是通过 bash shell 的啦!
# atrun uid=0 gid=0
# mail root 0
umask 22
范例二:将上述的第
....(中间省略许多的环境变量项目)....
cd /etc/cron\.d || {
echo 'Execution directory inaccessible' >&2
exit 1
}
${SHELL:-/bin/sh} << 'marcinDELIMITER410efc26'
/bin/mail -s "testing at job" root < /root/.bashrc
marcinDELIMITER410efc26
# 这一行最重要!
# 你可以看到指令执行的目录 (/root),还有多个环境变量与实际的指令内容啦!
2015/08/05 停电,我想要在 2015/08/04 23:00 关机?
[root@study ~]# at 23:00 2015-08-04
at> /bin/sync
at> /bin/sync
at> /sbin/shutdown -h now
at> <EOT>
job 3 at Tue Aug 4 23:00:00 2015
范例三:由于机房预计于
# 您瞧瞧! at 还可以在一个工作内输入多个指令呢!不错吧
```

