# Redis的设计与实现SDS篇

### 1.SDS 与 C 字符串的区别

##### 减少修改字符串时带来的内存重分配次数

>  因为 C 字符串并不记录自身的长度， 所以对于一个包含了 `N` 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 `N+1` 个字符长的数组（额外的一个字符空间用于保存空字符）。

因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：

- **如果程序执行的是增长字符串的操作，那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。 **
- **如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏**

举个例子， 如果我们持有一个值为 `"Redis"` 的 C 字符串 `s` ， 那么为了将 `s` 的值改为 `"Redis Cluster"` ， 在执行：

```
strcat(s, " Cluster");
```

之前， 我们需要先使用内存重分配操作， 扩展 `s` 的空间。

之后， 如果我们又打算将 `s` 的值从 `"Redis Cluster"` 改为 `"Redis Cluster Tutorial"` ， 那么在执行：

```
strcat(s, " Tutorial");
```

之前， 我们需要再次使用内存重分配扩展 `s` 的空间， 诸如此类。

内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作：

- 在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。
- 但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。

为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， `buf` 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 `free` 属性记录。

通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。

##### 空间预分配

空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。

- 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `13` 字节， 那么程序也会分配 `13` 字节的未使用空间， SDS 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。
- 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。

**总结：在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。**通过这种预分配策略， SDS 将连续增长 `N` 次字符串所需的内存重分配次数从必定 `N` 次降低为最多 `N` 次

##### 惰性空间释放

```
sdstrim(s, "XY");   // 移除 SDS 字符串中的所有 'X' 和 'Y'
```

![digraph {      label = "\n 图 2-14    执行 sdstrim 之前的 SDS";      rankdir = LR;      node [shape = record];      //      sdshdr [label = "sdshdr | free \n 0 | len \n 11 | <buf> buf"];      buf [label = " { 'X' | 'Y' | 'X' | 'X' | 'Y' | 'a' | 'b' | 'c' | 'X' | 'Y' | 'Y' | '\\0' } "];      //      sdshdr:buf -> buf;  }](http://redisbook.com/_images/graphviz-e0b39c48a2c522f5f7802f1e325b5cb25ac92579.png)

```
sdscat(s, " Redis");
```

![digraph {      label = "\n 图 2-16    执行 sdscat 之后的的 SDS";      rankdir = LR;      node [shape = record];      //      sdshdr [label = "sdshdr | free \n 2 | len \n 9 | <buf> buf"];      buf [label = " { 'a' | 'b' | 'c' | ' ' | 'R' | 'e' | 'd' | 'i' | 's' | '\\0' | <1> | <2> } "];      //      sdshdr:buf -> buf;  }](http://redisbook.com/_images/graphviz-d518d01875adb59245dce35983eab3528f2e59ea.png)

通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。

与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

##### 二进制安全

> C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
>
> 举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图 2-17 所示， 那么这种格式就不能使用 C 字符串来保存， 因为 C 字符串所用的函数只会识别出其中的 `"Redis"` ， 而忽略之后的 `"Cluster"` 。

虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们将 SDS 的 `buf` 属性称为字节数组的原因 —— **Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据**

##### 兼容部分 C 字符串函数

虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。

| C 字符串                                             | SDS                                                  |
| :--------------------------------------------------- | :--------------------------------------------------- |
| 获取字符串长度的复杂度为 O(N) 。                     | 获取字符串长度的复杂度为 O(1) 。                     |
| API 是不安全的，可能会造成缓冲区溢出。               | API 是安全的，不会造成缓冲区溢出。                   |
| 修改字符串长度 `N` 次必然需要执行 `N` 次内存重分配。 | 修改字符串长度 `N` 次最多需要执行 `N` 次内存重分配。 |
| 只能保存文本数据。                                   | 可以保存文本或者二进制数据。                         |
| 可以使用所有 `<string.h>` 库中的函数。               | 可以使用一部分 `<string.h>` 库中的函数。             |

### 2.SDS API

| `dsnew`       | 创建一个包含给定 C 字符串的 SDS 。                           | O(N) ， `N` 为给定 C 字符串的长度。                          |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `sdsempty`    | 创建一个不包含任何内容的空 SDS 。                            | O(1)                                                         |
| `sdsfree`     | 释放给定的 SDS 。                                            | O(1)                                                         |
| `sdslen`      | 返回 SDS 的已使用空间字节数。                                | 这个值可以通过读取 SDS 的 `len` 属性来直接获得， 复杂度为 O(1) 。 |
| `sdsavail`    | 返回 SDS 的未使用空间字节数。                                | 这个值可以通过读取 SDS 的 `free` 属性来直接获得， 复杂度为 O(1) 。 |
| `sdsdup`      | 创建一个给定 SDS 的副本（copy）。                            | O(N) ， `N` 为给定 SDS 的长度。                              |
| `sdsclear`    | 清空 SDS 保存的字符串内容。                                  | 因为惰性空间释放策略，复杂度为 O(1) 。                       |
| `sdscat`      | 将给定 C 字符串拼接到 SDS 字符串的末尾。                     | O(N) ， `N` 为被拼接 C 字符串的长度。                        |
| `sdscatsds`   | 将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。             | O(N) ， `N` 为被拼接 SDS 字符串的长度。                      |
| `sdscpy`      | 将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。   | O(N) ， `N` 为被复制 C 字符串的长度。                        |
| `sdsgrowzero` | 用空字符将 SDS 扩展至给定长度。                              | O(N) ， `N` 为扩展新增的字节数。                             |
| `sdsrange`    | 保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。 | O(N) ， `N` 为被保留数据的字节数。                           |
| `sdstrim`     | 接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。 | O(M*N) ， `M` 为 SDS 的长度， `N` 为给定 C 字符串的长度。    |
| `sdscmp`      | 对比两个 SDS 字符串是否相同。                                | O(N) ， `N` 为两个 SDS 中较短的那个 SDS 的长度。             |