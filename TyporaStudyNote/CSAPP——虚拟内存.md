# CSAPP——虚拟内存

> 每个进程“看起来“都是在独占地使用主存。这是一个假象。
>
> 主要是通过虚拟内存实现的，**每个进程看到的内存都是一致的。**

**![img](https://hansimov.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzietxOnE2XCBTZHJ7%2F-MHzj3WC193cZbjm8s4A%2F01-13%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png?alt=media&token=e75f285a-1895-46f5-83fd-e8857326e5f9)**

- 在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的

- 地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

- **每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。**

  

- **程序代码和数据。**对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。

- **堆。**代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。

- **共享库。**大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。

- **栈。**位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。

- **内核虚拟内存。**地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

**基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。**

## 文件

**文件**就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的

文件为应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备，“系统中各式各样的IO设备都被应用程序看作了文件。”

## **系统之间利用网络通信**

> 我们一直是把系统视为一个孤立的硬件和软件的集合体，实际上现代系统可以通过网络和其他系统连接到一起。

- **对于一个单独的系统，网络是一个IO设备。因为系统可以从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是到达本地的磁盘驱动器。同样的系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。**

![img](https://hansimov.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkTNuWPTixbySY2Yc%2F01-14%20%E7%BD%91%E7%BB%9C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8DIO%E8%AE%BE%E5%A4%87.png?alt=media&token=d06f41b1-bb97-42e1-ad6d-35f30948cbc7)

随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。

 回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。此后在远端运行 hello 程序包括如图 1-15  所示的五个基本步骤。

![img](https://hansimov.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzkHZkDb2pAz2UFj6L%2F-MHzkrKbCqYNGK5oVdPg%2F01-15%20%E5%88%A9%E7%94%A8telnet%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8Chello.png?alt=media&token=686ab00c-5876-4a23-bb52-6760cdc22591)

当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。 这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的

## **重要小结**

- **那就是系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。**

强调几个贯穿计算机系统所有方面的重要概念。我们会在本书中的多处讨论这些概念的重要性。

-  Amdahl 定律

当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为ToldT_{old}Told 。假设系统某部分所需执行时间与该时间的比例为 α\alphaα ，而该部分性能提升比例为 kkk 。即该部分初始所需时间为 αTold\alpha T_{old}αTold ，现在所需时间为 (αTold)/k(\alpha T_{old}) / k(αTold)/k 。因此，总的执行时间应为



```
Tnew=(1−α)Told+(αTold)/k=Told[(1−α)+α/k]

由此，可以计算加速比为


```

举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%（α =0.6），其加速比例因子为 3（k=3）。则我们可以获得的加速比为 1/[0.4+0.6/3]=1.67 倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl 定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

```
1.
a=1500/2500 =0.6 
k=150/100 =1.5 
T=0.4*25+0.6*25/1.5=20
25/20=1.25

25/1.67=14.97
1000 /100=10
1500/5=300

2.
T (old)=2
T (new)=1
T (new)=0.2*2+0.8*2/k
k=2.67
```



## 并发和并行

有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语**并发**（concurrency）是一个通用的概念，指一个同时具有多个活动的**系统**

而术语**并行**（parallelism）指的是用并发来使一个系统运行得更快。

并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。

**并发是多活动状态的系统**

**并行是让并发运行的更快一点**

1. 线程级并发

   构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在**一个进程中执行多个控制流**

   并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互

   这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为**单处理器系统**。

当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个**多处理器系统**。

**多核处理器**是将多个 CPU（称为“核”）集成到一个集成电路芯片上。图 1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个 CPU 核，每个核都有自己的 L1 和 L2 高速缓存，其中的 L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。

![img](https://hansimov.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzl0fd6lZg8Hh-AE9H%2F-MI-7jCviAytfKKxpbQG%2F01-17%20%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png?alt=media&token=268e2b0a-03ce-4e72-92ac-b209f776effe)

**超线程**，有时称为**同时多线程**（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。

常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。

比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。

Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50 年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即**找到书写应用程序的方法**利用多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50 年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。。

2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086，需要多个（通常是 3～10 个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期 2～4 条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。在第 4 章中，我们会研究**流水线**（pipelining）的使用。在流水线中，将执行**一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，**用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率

3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和 AMD 处理器都具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令。

## 计算机系统中抽象的重要性

为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如 Java 类的声明和C语言的函数原型。

计算机系统中使用的几个抽象：

实际处理器硬件——指令集架构

主存和IO设备——虚拟内存

IO设备——文件

处理器，主存，IO设备——进程

操作系统，处理器，IO设备，主存——虚拟机

**文件是对 I/O 设备的抽象**

**虚拟内存是对程序存储器的抽象**

**进程是对一个正在运行的程序的抽象**

**虚拟机它提供对整个计算机的抽象**

## **小结**

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。

计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式

程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令，花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据。所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。

操作系统内核是应用程序和硬件之间的媒介。

它提供三个基本的抽象∶1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和 I/O 设备的抽象。

