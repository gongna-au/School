# 深入理解计算机系统的学习

### 1.**复习指针  **

**指针类型（int *）的存储过程和原理**

```c
// 	p = a;    //这种赋值方式错误
```

错误的操作,不能把一个具体的数字赋给指针（类型不匹配），

一个指针类型，一个int类型

###   指针存储过程和原理：

![preview](https://pic1.zhimg.com/v2-979d4bbfc898dbf3faef35af3681ddc4_r.jpg)

> **int型的指针 `int *p`就是来存int型的数的地址**

**我们用int类型保存一些整型的数据， 我们也会用char来存储字符： char ch = 'a'。我们需要用一个东西来储存这些数据的地址，这就是指针的来历。**

![img](https://pic3.zhimg.com/80/v2-0897f64ced3892294f1e3a05c4f32fce_720w.jpg)

**指针是数据的地址，指针变量才是保存地址的变量。**

### 2.**回顾内存**

**我们所描述的内存实际上是对物理内存的抽象——是一种虚拟内存**

![img](https://pic3.zhimg.com/80/v2-59182395f339e2a510def9ea5040b9ea_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-c10d419c8e9e3aa7d4e4529d0f776c67_1440w.jpg)

**内存是一个很大的线性数组**

每个字节一个编号，从零开始，例如一个256M的内存编号计算为256X1024X1024=268435455；

这个编号为这个字节的地址。**所以说指针本质就是字节的编号**，那如果一个数据它所占据的地址需要的字节比较多（int类型的占了四个字节），那么这个数据的地址就是对应字节编号最小的那个，**地址值最小的那个字节的地址**

**指针变量 和 指向关系**

用来保存 指针 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 

![img](https://pic2.zhimg.com/80/v2-1c11f497415dd505eb86c3366e5f6691_1440w.jpg)

上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块

`int a`  定义了int型的变量。(a 里面放int类型的数)

`int * p` 定义了指向int类型数的指针。(p 里面放指针，指向int数据)

`int arr[3] ` 定义了int类型的数组(arr 里面放三个int类型的数)

`int (* arr)[3]` **定义了指向含有三个int类型的数组的指针**，含有三个int* 的数组,意思是这个数组里放的是用来储存int型数据的地址的指针变量 (arr 里面放三个指针，都指向int型数据的地址)

`int (*p)(int,int)` **定义了一个指向含有两个int形参，返回一个int类型的函数的指针**。

给指针给值--&

把指向的内存块的地址给这个指针

给指针解值--*

把指针指向的这个内存块的值拿出

```c
int* p1  = & num;
int* p3 = p1;

//通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。
```

**指针变量也是变量**

**因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 指针的类型，指针的值**

指针的值就是指向的内存块的地址呗

指针的类型就是决定它指向什么类型的内存块，是int类型四个字节，还是char类型，一个字节。

> 指针的类型：指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息。一般指针变量的类型要和它指向的数据的类型匹配。
>
> 由于num的地址是0028FF40，因此p1  和  p2的值都是0028FF40
>
> *p1  :  将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。
>
> 
>
> *p2  :  将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即'a'。
>
> 同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。

结构体指针

先定义一个结构体

```c
typedef struct
{
    char name[31];
    int age;
    float score;
}Student;
```

把p定义为结构体指针

`Student *p`

p -> name="gn";

p -> score=100;

p ->age=18;

数组指针

a=1

b=4

c=5

int *arr[3]={&a,&b,&c}

*a=1

*b=3

*c=4

int *arr[3]={a,b,c}

函数指针



`int (*max) (int a,int b)`

int *(arr[3]) 等价于int *arr[3]

### 编译原理学习

![image-20210408193106063](/home/gongna/.config/Typora/typora-user-images/image-20210408193106063.png)

编译器的“前端”技术分为词法分析、语法分析和语义分析三个部分。

**词法分析**

> 识别 age 这样的标识符。它以字母开头，后面可以是字母或数字，直到遇到第一个既不是字母又不是数字的字符时结束。识别 >= 这样的操作符。 当扫描到一个 > 字符的时候，就要注意，它可能是一个GT（Greater Than，大于）操作符。但由于 GE（Greater Equal，大于等于）也是以 >开头的，所以再往下再看一位，如果是 =，那么这个 Token 就是 GE，否则就是 GT。识别 45 这样的数字字面量。当扫描到一个数字字符的时候，就开始把它看做数字，直到遇到非数字的字符。

这些规则可以通过手写程序来实现。事实上，很多编译器的词法分析器都是手写实现的，例如 GNU 的 C 语言编译器。如果嫌手写麻烦，或者你想花更多时间陪恋人或家人，也可以偷点儿懒，用词法分析器的生成工具来生成，比如 Lex（或其 GNU 版本，Flex）。识别 age 这样的标识符。它以字母开头，后面可以是字母或数字，直到遇到第一个既不是字母又不是数字的字符时结束。识别 >= 这样的操作符。 当扫描到一个 > 字符的时候，就要注意，它可能是一个GT（Greater Than，大于）操作符。但由于 GE（Greater Equal，大于等于）也是以 >开头的，所以再往下再看一位，如果是 =，那么这个 Token 就是 GE，否则就是 GT。识别 45 这样的数字字面量。当扫描到一个数字字符的时候，就开始把它看做数字，直到遇到非数字的字符的，**这些规则用“正则文法”表达**，**符合正则文法的表达式称为“正则表达式”**。**生成工具可以读入正则表达式**，**生成一种叫“有限自动机”的算法，来完成具体的词法分析工作**。**不要被“正则文法”和“有限自动机”吓到。正则文法是一种最普通、最常见的规则，写正则表达式的时候用的就是正则文法**。我们前面描述的几个规则，都可以看成口语化的正则文法。**有限自动机是有限个状态的自动机器**。![image-20210408194052817](/home/gongna/.config/Typora/typora-user-images/image-20210408194052817.png)我们可以拿抽水马桶举例，它分为两个状态：“注水”和“水满”。摁下冲马桶的按钮，它转到“注水”的状态，而浮球上升到一定高度，就会把注水阀门关闭，它转到“水满”状态。**词法分析器也是一样，它分析整个程序的字符串，当遇到不同的字符时，会驱使它迁移到不同的状态。例如，词法分析程序在扫描 age 的时候，处于“标识符”状态，等它遇到一个> 符号，就切换到“比较操作符”的状态。词法分析过程，就是这样一个个状态迁移的过程。**

![image-20210408194113687](/home/gongna/.config/Typora/typora-user-images/image-20210408194113687.png)

你也许熟悉正则表达式，因为我们在编程过程中经常用正则表达式来做用户输入的校验，例如是否输入了一个正确的电子邮件地址，这其实就是在做词法分析，你应该用过.

**语法分析**

**语法分析编译器下一个阶段的工作是语法分析**。词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的。以自然语言为例。自然语言有定义良好的语法结构，比如，“我喜欢又聪明又勇敢的你”这个句子包含了“主、谓、宾”三个部分。主语是“我”，谓语是“喜欢”，宾语部分是“又聪明又勇敢的你”。其中宾语部分又可以拆成两部分，“又聪明又勇敢”是定语部分，用来修饰“你”。定语部分又可以分成“聪明”和“勇敢”两个最小的单位。这样拆下来，会构造一棵树，里面的每个子树都有一定的结构，而这个结构要符合语法。比如，汉语是用“主谓宾”的结构，日语是用“主宾谓”的结构。这时，我们说汉语和日语的语法规则是不同的。程序也有定义良好的语法结构，它的语法分析过程，就是构造这么一棵树。

![image-20210408194735543](/home/gongna/.config/Typora/typora-user-images/image-20210408194735543.png)一个程序就是一棵树，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点

![image-20210408195503758](/home/gongna/.config/Typora/typora-user-images/image-20210408195503758.png)

形成 AST 以后有什么好处呢？就是计算机很容易去处理。比如，针对表达式形成的这棵树，从根节点遍历整棵树就可以获得表达式的值。基于这个原理，我们可以实现一个计算器，并实现自定义公式功能。

如果再把循环语句、判断语句、赋值语句等节点加到 AST 上，并解释执行它，那么你实际上就实现了一个脚本语言。而执行脚本语言的过程，就是遍历 AST 的过程。

好了，你已经知道了 AST 的作用，那么怎样写程序构造它呢？首先建立一个根节点，这个节点代表整个程序，从头开始扫描token 串(这里的token其实就是词法分析中我们讲的“单词”)，来分别构建它的子节点。举个例子，看到一个 `int`，我先建立一个声明变量的节点,又看到`int 后面跟着 age`，所以我再建立一个子节点放变量名，之后遇到 =，意味着这个变量有初始化值，再建立一个节子节点来放等号；最后，遇到“字面量”，其值是 45，再跟一个子节点放45，一棵子树就扫描完毕了。程序退回到根节点，开始构建根节点的第二个子节点。这样递归地扫描，直到构建起一棵完整的树。这就是脚本语言实现的逻辑。

![image-20210408195758131](/home/gongna/.config/Typora/typora-user-images/image-20210408195758131.png)

这个算法就是非常常用的递归下降算法。是不是很简单？你完全可以动手写出来。**递归下降算法是一种自顶向下的算法**，与之对应的，还有自底向上的算法。这个算法会先将最下面的叶子节点识别出来，然后再组装上一级节点。有点儿像搭积木，我们总是先构造出小的单元，然后再组装成更大的单元。原理就是这么简单。也许你会想，除了手写，有没有偷懒的、更省事的方法呢？多一些时间去陪家人总不是坏事。你现在已经有了一定的经验，大可以去找找看有没有现成的工具，比如 Yacc（或 GNU 的版本，Bison）、Antlr、JavaCC 等。实际上，你可以在维基百科里找到一个挺大的清单，我把它放到了 CSDN 的博客上，其中对各种工具的特性做了比较。顺理成章地，**你还能找到很多开源的语法规则文件**，**改一改**，**就能用工具生成你的语法分析器**。很多同学其实已经做过语法解析的工作，**比如编写一个自定义公式的功能**，**对公式的解析就是语法分析过程**。**另一个例子是分析日志文件等文本文件**，**对每行日志的解析**，本质上也是语法分析过程。**解析用** XML、**JSON** **写的各种配置文件**、**模型 定义文件的过程**，其实本质也是语法分析过程，甚至还包含了语义分析工作。语义分析。

**语义分析**

好了，讲完了词法分析、语法分析，编译器接下来做的工作是语义分析。

说白了，语义分析就是要让计算机理解我们的真实意图，把一些模棱两可的地方消除掉。以“You can never drink too much water.” 这句话为例。它的确切含义是什么？是“你不能喝太多水”，还是“你喝多少水都不嫌多”？实际上，这两种解释都是可以的，我们只有联系上下文才能知道它的准确含义。

你可能会觉得理解自然语言的含义已经很难了，所以计算机语言的语义分析也一定很难。其实语义分析没那么复杂，因为计算机语言的语义一般可以表达为一些规则，你只要检查是否符合这些规则就行了。

比如：语义分析基本上就是做这样的事情，也就是根据语义规则进行分析判断。语义分析工作的某些成果，会作为属性标注在抽象语法树上，比如在 age 这个标识符节点和 45 这个字面量节点上，都会标识它的数据类型是 int 型的。在这个树上还可以标记很多属性，有些属性是在之前的两个阶段就被标注上了，比如所处的源代码行号，这一行的第几个字符。这样，在编译程序报错的时候，就可以比较清楚地了解出错的位置。做了这些属性标注以后，编译器在后面就可以依据这些信息生成目标代码了，我们在编译技术的后端部分会去讲。重点内容：某个表达式的计算结果是什么数据类型？如果有数据类型不匹配的情况，是否要做自动转换？如果在一个代码块的内部和外部有相同名称的变量，我在执行的时候到底用哪个？ 就像“我喜欢又聪明又勇敢的你”中的“你”，到底指的是谁，需要明确。在同一个作用域内，不允许有两个名称相同的变量，这是唯一性检查。你不能刚声明一个变量 a，紧接着又声明同样名称的一个变量 a，这就不允许了。词法分析是把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现。

我们来描述一下标识符、比较操作符和数字字面量这三种 Token 的词法规则。我们就是依据这样的规则，来构造有限自动机的。这样，词法分析程序在遇到 age、>= 和45 时，会分别识别成标识符、比较操作符和数字字面量。不过上面的图只是一个简化的示意图，一个严格意义上的有限自动机是下面这种画法：标识符：第一个字符必须是字母，后面的字符可以是字母或数字。

比较操作符：> 和 >=（其他比较操作符暂时忽略）。

数字字面量：全部由数字构成（像带小数点的浮点数，暂时不管它）。

我来解释一下上图的 5 种状态。

![image-20210408211010830](/home/gongna/.config/Typora/typora-user-images/image-20210408211010830.png)

1. 初始状态：刚开始启动词法分析的时候，程序所处的状态。
2.  标识符状态：在初始状态时，当第一个字符是字母的时候，迁移到状态 2。当后续字符是字母和数字时，保留在状态 2。如果不是，就离开状态 2，写下该 Token，回到初始状态。
3.  大于操作符（GT）：在初始状态时，当第一个字符是 > 时，进入这个状态。它是比较操作符的一种情况。
4.  大于等于操作符（GE）：如果状态 3 的下一个字符是 =，就进入状态 4，变成 >=。它也是比较操作符的一种情况。
5.  数字字面量：在初始状态时，下一个字符是数字，进入这个状态。如果后续仍是数字，就保持在状态 5。这里我想补充一下，你能看到上图中的圆圈有单线的也有双线的。双线的意思是这个状态已经是一个合法的 Token 了，单线的意思是这个状态还是临时状态。

按照这 5 种状态迁移过程，你很容易编成程序（我用 Java 写了代码示例，你可以用自己熟悉的语言编写）。我们先从状态 1 开始，在遇到不同的字符时，分别进入 2、3、5 三个状态：

![image-20210408211439141](/home/gongna/.config/Typora/typora-user-images/image-20210408211439141.png)

上面的代码中，nextState 是接下来要进入的状态。我用 Java 中的枚举（enum）类型定义了一些枚举值来代表不同的状态，让代码更容易读。其中 Token 是自定义的一个数据结构，它有两个主要的属性：一个是“type”，就是Token 的类型，它用的也是一个枚举类型的值；一个是“text”，也就是这个 Token 的文本值。我们接着处理进入 2、3、5 三个状态之后的状态迁移过程

![image-20210408211652020](/home/gongna/.config/Typora/typora-user-images/image-20210408211652020.png)

运行这个示例程序，你就会成功地解析类似“age >= 45”这样的程序语句。不过，你可以先根据我的讲解自己实现一下，然后再去参考这个示例程序。示例程序的输出如下，其中第一列是 Token 的类型，第二列是 Token 的文本值

但其实已经讲清楚了词法原理，就是依据构造好的有限自动机，在不同的状态中迁移，从而解析出 Token 来。你只要再扩展这个有限自动机，增加里面的状态和迁移路线，就可以逐步实现一个完整的词法分析器了

初识正则表达式但是，这里存在一个问题。我们在描述词法规则时用了自然语言。比如，在描述标识符的规则时，我们是这样表达的：第一个字符必须是字母，后面的字符可以是字母或数字。

这样描述规则并不精确，我们需要换一种严谨的表达方式，这种方式就是正则表达式。上面的例子涉及了 4 种 Token，这 4 种 Token 用正则表达式表达，是下面的样子

![image-20210408211955469](/home/gongna/.config/Typora/typora-user-images/image-20210408211955469.png)

解析 int age = 40，处理标识符和关键字规则的冲突1234Id :        [a-zA-Z_] ([a-zA-Z_] | [0-9])*IntLiteral: [0-9]+GT :        '>'GE :        '>='复制代码

说完正则表达式，我们接着去处理其他词法，比如解析“int age = 40”这个语句，以这个语句为例研究一下词法分析中会遇到的问题：多个规则之间的冲突。如果我们把这个语句涉及的词法规则用正则表达式写出来，是下面这个样子：这时候，你可能会发现这样一个问题：int 这个关键字，与标识符很相似，都是以字母开头，后面跟着其他字母。

换句话说，int 这个字符串，既符合标识符的规则，又符合 int 这个关键字的规则，这两个规则发生了重叠。这样就起冲突了，我们扫描字符串的时候，到底该用哪个规则呢？当然，我们心里知道，int 这个关键字的规则，比标识符的规则优先级高。普通的标识符是不允许跟这些关键字重名的。

关键字是语言设计中作为语法要素的词汇，例如表示数据类型的 int、char，表示程序结构的 while、if，表述特殊数据取值的 null、NAN 等。除了关键字，还有一些词汇叫保留字。保留字在当前的语言设计中还没用到，但是保留下来，因为将来会用到。我们命名自己的变量、类名称，不可以用到跟关键字和保留字相同的字符串。那么我们在词法分析器中，如何把关键字和保留字跟标识符区分开呢？

![image-20210408212558692](/home/gongna/.config/Typora/typora-user-images/image-20210408212558692.png)



这个思路其实很简单。在识别普通的标识符之前，你先看看它是关键字还是保留字就可以了。具体做法是：相应的代码也修改一下，文稿里的第一段代码要改成：第二段代码要增加下面的语句：当第一个字符是 i 的时候，我们让它进入一个特殊的状态。接下来，如果它遇到 n 和 t，就进入状态 4。但这还没有结束，如果后续的字符还有其他的字母和数字，它又变成了普通的标识符。比如，我们可以声明一个 intA（int 和A 是连着的）这样的变量，而不会跟 int 关键字冲突。

“2 + 3 * 5”的运算。

在学习语法分析时，我们习惯把上面的公式称为表达式。这个表达式看上去很简单，但你能借此学到很多语法分析的原理，例如左递归、优先级和结合性等问题。当然了，要实现上面的表达式，你必须能分析它的语法。不过在此之前，我想先带你解析一下变量声明语句的语法，以便让你循序渐进地掌握语法分析

# 寻址方式与用于寻址的寄存器小结（8086）

1、直接寻址

直接指以立即数形式给出地址，不存在任何的歪歪扭扭。所谓立即数则是在指令中已经直接给出的地址。

我们知道，指令结构采用“操作码+地址码”的形式，而立即数则在地址码中给出。

**寻址方式**：**在指令中得到操作数的方式**

汇编中，执行指令的本质都是：操作码和操作数

操作数表示的是执行这条指令所需要的数据，可以是地址也可以使这个数本身，

MOV AL，0x04

机器码：0xB004

这个机器码是一个指令，其高字节为操作码：0xB0告诉CPU把一个立即数放入寄存器AL中（MOV AL, immed8），低字节0x04是操作数，代表立即数的值

MOV AL， [0x04]

机器码：0x8A0425**04000000**

这里的操作码：0x8A0425告诉CPU从一个偏移地址的内存中取出一个字节数据到AL中。

操作数: 0x04为该偏移地址，这里的0x04是一个立即数，只不过解释为偏移地址。



MOV AL，[RCX+0x04]

机器码：8A4104

操作码：0x8A41,告诉CPU利用RCX中的值和偏移量一起作为内存偏移地址，取出该偏移地址中内存的一个字节数据到AL中

操作数：0x04，就是一个固定偏移量，是一个立即数，解释为地址偏移量。

有符号的数据类型进行移位操作：

> 负数左移，符号位始终为一
>
> 正数左移，所有位左移，可能变为负数
>
> 负数进行右移，取绝对值，然后右移，再取相反数。
>
> 正数进行右移动，所有位右移动。

**而mov的作用分情况讨论:**

**对于操作数是寄存器本身值的，那么就是直接操作寄存器内部存储的值，比如 movl %esp，%ebp；**

**如果操作数对应的是内存中的数据，那么就是操作寄存器中存储的地址对应的内存中的值，比如movl 8（%ebp），%ebx .对于CSAPP中使用的汇编，一般可以通过操作数是否有括号进行区分**

