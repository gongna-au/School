# **指针**

****

**需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代
码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址**

* 数据在内存中的地址也称为指针
* 我们认为变量名表示的是数据本身，**如果一个变量存储了一份数据的指针，我们就称它为指针变量**

* **指针变量的值就是某份数据的地址**

* 这份数据可以是数组、字符串、函数，**也可以是另外的一个普通变量或指针变量**
* **现在假设有一个 char 类型的变量 c，它存储了字符 'K'（ASCII 码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。**

p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。再如：
int a = 100;
int *p_a = &a;

**在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，
p_a 需要的一个地址，a 前面必须要加取地址符&，否则是不对的**

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

***是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带*。而给 p1、p2 赋值时，因为已经知道了它
是一个指针变量，就没必要多此一举再带上*，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针
变量时必须带*，给指针变量赋值时不能带*。**

* 指针变量也可以连续定义

  

  

  #### **通过指针变量取得数据**

  指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为*pointer

**CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过*p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”。**

#### 牢牢记住一点：指针存数据的地址，要想取得地址上的数据，给指针变量前面加*

也就是说：普通变量和指针变量都是地址的助记符，但是普通变量我们认为它就是数据本身，除了数组名，函数名，而指针变量我们认为它代表数据的地址，要想取得指针上的数据，必须得往前面加*，指针变量与普通变量还有不同的一点是：在CPU的角度，普通变量一次运算就可以得到数据的值，所以我们认为它本身就代表数据的值，但是指针变量要进行两次运算，过程如下：

* **假设变量 a、p 的地址分别为 0X1000、0XF0A0**

****

* **程序被编译和链接后，a、p 被替换成相应的地址**
* 我们可以建立一个模型来理解，每一个内存块上放的是数据，内存块下面是地址。当程序被编译连接后，程序中的a与p都变成了内存块下面的地址。a我们可以根据地址直接知道数据本身，但是一个单纯的p我们也能知道一个数据，这个数据是个地址值，你拿这个地址值没啥用啊兄弟！！所以你要根据地址值来在找数据，所以你往前面加了*
* 使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。
* **本质是什么？本质是你这个变量地址上面的数据是不是你想要的，一个p（代表它的地址0XF0A0）它上面数据不是我想要的，我给它前面加个*，它就会把p(这个0XF0A0)上面的数据变成地址，所以*p 这个整体编译完代表0XF0A0,a这个整体编译完也代表0XF0A0**
* 本质是程序知道小方块下面的地址，就可以取得方块里面的值。***的作用就是数据变地址**

#### *的作用就是数据变地址！！！

**指针除了可以获取内存上的数据，也可以修改内存上的数据**

****

很容易理解啊！！你变量可以赋值，可以改动，不就是你编译完，你程序知道小方块下面的地址，然后你说：去把这个地址上的值改成XXXX，然后，程序就把小方块里面的值改了。

**定义指针变量时的*和使用指针变量时的*意义完全不同**

定义时只是用来指明 p 是一个指针变量，使用时*，先知道指针本身地址而读取到里面内存块里的数据，然后把这个数据当做地址，在得到这个地址上的数据！！！！。



**所以只要搞清楚，符号代表的是哪个内存块，你就可以知道怎么去操作这些值了。**

## 个人认为所有的指针问题你都可以抽象成下面这个模型

***（）把括号里的东西当地址，查到的内存块**

**&（）把括号里的东西当内存块得到的内存块下面的地址**



上面是内存块

下面是地址

而且认为一切标识符就是字母，都是指内存块

```
**小内存块1**  	 **小内存块2**


**地址1**  		**地址2**
```

**关于 * 和 & 的谜题**

假设有一个 int 类型的变量 a，pa 是指向它的指针，那么*&a 和&*pa 分别是什么意思呢？

*&a 可以理解为*(&a)，&a 表示取变量 a 的地址（等价于 pa），*(&a)表示取这个地址上的数据（等价于 *pa），
绕来绕去，又回到了原点，*&a 仍然等价于 a。
&*pa 可以理解为&(*pa)，*pa 表示取得 pa 指向的数据（等价于 a），&(*pa)表示数据的地址（等价于 &a），所
以&*pa 等价于 pa。

**内存块等价于标识符，地址等价于&标识符**

### 指针变量的运算（加法、减法和比较运算）

内存块大小的一致性！！

int a=100;

int *p;

p=&a;

意味着：p这个指针变量内存块的大小是4个字节

而且，把它里面存放的数据当做地址后得到的内存块也就是a也是4个字节！！！

**为了使指针的加减运算具有了现实的意义，系统在给指针加一时，实际是给指针变量加1*sizeof（类型）**  **加n就是给指针变量加n*sizeof（类型）**

所以对于指向普通变量的指针，我们往往不进行加减运算，
虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据

#### 指针变量的比较用来判断*p能否得到同样的内存块

**指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。**

**不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义**

定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。在 C 语言中我们将第 0 个元素的地址称为数组的首地址。

**如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。**

**数组指针指向的是数组中的一个具体元素，而不是整个数组**

**所以数组指针的类型和数组元素的类型有关**

**p 并不知道它指向的是一个数组**

**p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编
码**

**在求数组的长度时不能使用 sizeof(p) / sizeof(int)，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数**

**也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。**

**不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素**

int * p   假设n指向数组的第n个元素

*p++

因为*与++是同一优先级，所以，代表对p取第n个内存块的值

但是 *++p代表取n取第n+1个内存块的值

(*p)++表示对内存块的值加1；p仍然指向第n块

```
 char *str = "http://c.biancheng.net";


 char str[] = "http://c.biancheng.net";
 char *pstr = str;
```

定义一个变量，让指针指向变量，与直接让指针指向一个字符串是完全不同的，

**因为有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限**

因为字符数组是变量，变量你可以改变它的值，常量无法改变！而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限.

```
这句话的意思很明显啊
char *str[]="sdoafohfishdaig"
str[0]='e'
str[6]='g'
//都是错误的
但是str="jidjierfr"
是正确的，因为这里不是修改常量sdoafohfishdaig的值，而是让指针重新指向一个字符串"jidjierfr"
可以更改指针变量本身的指向；
不能修改常量字符串中的字符，数组字符串你照样可以修改，有啥不能修改的

```

### 指针变量作为函数参数

**用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。**

> 因为你传参数进去相当于是实参对形参赋值，你里面所有的操作都是对外部实参的复制品-形参进行操作。你想修改实参的值，不可能，那么怎么才能修改，传实参的地址进去，一复制，你得到的还是实参的地址，那么，你知道实参的地址后不就可以对实参进行改变？？？

```
void swap(int *p1, int *p2){
 int temp; //临时变量
 temp = *p1;
 *p1 = *p2;
 *p2 = temp;
}

1

void swap(int *p1, int *p2){
 int* temp; //临时变量
 temp = p1;
 p1 = p2;
 p2 = temp;
}

2

1为正确的，为什么，分析2，p1与p2是形指针，
temp = p1;  
 p1 = p2;把形指针p2内存块上的值赋值给了p1的内存块；就是把两个内存块上的数交换了一下，此时*p1确实是b的值，*p2确实是a的值，但是！！！你拿的是形指针，而你外部实指针内存块上的值并没有改变！！！
 p2 = temp;
 
 
 
 要想改变外部实参的值，你就直接通过传进去的地址值，找到你要改的内存块，对内存块直接进行改变，不要想着你改变指针内存块里面的地址值，因为你在里面改变的也只是形指针！！！！
 
 

```

#### "明确你的目的！找到你要改的内存块！！！，然后修改它！"

```
 int max(int intArr[6], int len){

 int i, maxValue = intArr[0];  
 for(i=1; i<len; i++){
 
 	if(maxValue < intArr[i]){ 
 		maxValue = intArr[i]
 	}
 } 
 return maxValue;
}


int max(int intArr[], int len){
 int i, maxValue = intArr[0]; 
 for(i=1; i<len; i++){
 	if(maxValue < intArr[i]){
 	maxValue = intArr[i];
  } 
 } return maxValue;
}



```

int intArr[6]好像定义了一个拥有 6 个元素的数组，调用 max() 时可以将数组的所有元素“一股脑”传递进来

**int intArr[]虽然定义了一个数组，但没有指定数组长度，好像可以接受任意长度的数组**

**实际上这两种形式的数组定义都是假象，不管是 int intArr[6]还是 int intArr[]都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为 int *intArr 这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针**.

**int intArr[6]这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。**

**需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。**



#### 参数的传递本质上是一次赋值的过程

**赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。**





### 函数运行结束后会销毁所有的局部数据的本质

**前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分 C 语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。**

> 函数调用结束“销毁局部数据并不是说真的销毁，而是放弃对这块内存的使用权限，后续的代码可以覆盖这些内存来干其他的事情，启示是：调用函数得到结果后，及时的获取结果，处理结果，打印结果，因为你局部的内存可能被覆盖。不及时的处理就容易的得到错误结果，还有就是，如果想打印函数局部的数据，你就在被覆盖之前打印，因为迟早里面的数据是要被覆盖的！！！！”

只要尽早的获取到可能被覆盖的局部数据，就不用担心，因为你获取的够早，已经得到了拷贝好的值。

### 未初始化的局部变量存在的危险

**未初始化=指向的内存不定=内存可能有读取与写入权限，但是也可能只有读取权限，只有读取权限时，不能对数据做更改，这是非常危险的！！！**

**前面我们讲过，未初始化的局部变量的值是不确定的，C 语言并没有对此作出规定，不同的编译器有不同的实现，我曾警告大家不要直接使用未初始化的局部变量。上面的代码中，str 就是一个未初始化的局部变量，它的值是不确定的，究竟指向哪块内存也是未知的，大多数情况下这块内存没有被分配或者没有读写权限，使用gets() 函数向它里面写入数据显然是错误的**

```
#include <stdio.h>
int main(){ 
char *str = NULL; 
gets(str); 
printf("%s\n", str); 
return 0;
}


运行程序后发现，还未等用户输入任何字符，printf() 就直接输出了(null)。我们有理由据此推断，gets() 和printf() 都对空指针做了特殊处理：

gets() 不会让用户输入字符串，也不会向指针指向的内存中写入数据
printf() 不会读取指针指向的内容，只是简单地给出提示，让程序员意识到使用了一个空指针
```

**这样能够从很大程度上增加程序的健壮性，防止对空指针进行无意义的操作。
其实，NULL 是在 stdio.h 中定义的一个宏，它的具体内容为：
#define NULL ((void *)0)
(void *)0 表示把数值 0 强制转换为 void *类型**

**最外层的( )把宏定义的内容括起来，防止发生歧义。从整体上来看，NULL 指向了地址为 0 的内存，而不是前面说的不指向任何数据。
在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，这个区域不存储有效数据，也不能被用户程序访问，将 NULL 指向这块区域很容易检测到违规指针。
关于虚拟地址空间的概念以及程序的内存分布，我们将在《C 语言内存精讲》专题中深入讲解，现在读者只需要记住，在大多数操作系统中，极小的地址通常不保存数据，也不允许程序访问，NULL 可以指向这段地址区间中的任何一个地址。注意，C 语言没有规定 NULL 的指向，只是大部分标准库约定成俗地将 NULL 指向 0，所以不要将 NULL 和 0 等同起来，例如下面的写法是不专业的：**

**对于空指针 NULL 的宏定义内容，上面只是对((void *)0)作了粗略的介绍，这里重点说一下 void *的含义。void 用在函数定义中可以表示函数没有返回值或者没有形式参数，用在这里表示指针指向的数据的类型是未知的。也就是说，void *表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换**

**大家理解 void *，它不是空指针的意思，而是实实在在的指针，只是指针指向的内存中不知道保存的是什么类型的数据**

不是什么空指针，而是空类型指针，实打实的一个指针，真真切切指向某一块数据，只是数据的类型我们不知到！！！

### 对，数组也有类型，这是很多读者没有意识到的

大部分 C 语言书籍对这一点也含糊其辞！我们可以将 int、float、char 等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。sizeof 就是根据符号的类型来计算长度的。



**对于数组 a，它的类型是 int [6]，表示这是一个拥有 6 个 int 数据的集合，1 个 int 的长度为 4，6 个 int 的长度为 4×6 = 24，sizeof 很容易求得**

整数、小数、数组、指针等不同类型的数据都是对内存的抽象，它们的名字用来指代不同的内存块，程序员在编码过程中不需要直接面对内存，使用这些名字将更加方便。
编译器在编译过程中会创建一张专门的表格用来保存名字以及名字对应的数据类型、地址、作用域等信息。
sizeof 是一个操作符，不是函数，使用 sizeof 时可以从这张表格中查询到符号的长度。
与普通变量名相比，数组名既有一般性也有特殊性：一般性表现在数组名也用来指代特定的内存块，也有类型和长度；特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。也就是说，有时候，数组名代表的是指针=地址，并不是数据本身

### 数组到底在什么时候会转换为指针

C 语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 & 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）。**这句话的意思是:有时候（sizeof 和&还有定义与声明），数组名转化为指针时，是一块储存地址的小内存块。**

### 指针始终是指针，它绝不可以改写成数组。

* 你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。

* 在特定的环境中，也就是数组作为函数形参**，也只有这种情况，**一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针

### 指针数组

int *arr[]

int * *p=arr

int **(* *p)括号里面的 *表示这是个指针，外面的int * 表示类型是int *，就是p内存块数据当做地址得到的内存块的类型。

最最最重要的一点是：括号里面* 就只是表示它是个指针，int *p也是一样， *就是表示p是个指针，p的内存块类型是int 

内存块的类型为int*表示什么呢？

内存块的类型为int * 表示，把这个内存块里的数据作为地址找到的内存块的里面是int *c

int arr[]

int *p

p=arr;

=*(p+1);

int *arr[]

int **p=arr;

*(arr+3)



**给内存块加值，其实加的是n*（类型）值**

int * arr[]

所以arr+1，相当于移的是sizeof(int *),每次移动都是移往下一个

### 定义数组指针来干嘛？

**数组指针可以用来访问二维数组的元素**

```
arr[3][4]={{1,2,3,4}{5,6,7,8}{9,10,11,12}}
int （*p）[4]=a
*(p+1)
*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址,编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；
就像一维数组的名字
但是遇到sizeof、& 一起使用时才表示整个数组，
```

指针数组，本质是数组，里面的元素是指针，

二维数组指针是一个指针

**函数名在表达式中有时也会被转换为该函数所在内存区域的首地址**

**我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针**

int * arr[]    指针数组

int（*p）[4] 数组指针

int （*p）func(int a,int b)

# C 语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。

**从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键！**

* 定义中被括号( )括起来的那部分

* 后缀操作符：括号( )表示这是一个函数，方括号[ ]表示这是一个数组

* 前缀操作符：星号*表示“指向 xxx 的指针

  

**int *p1[6]**

**首先从p1开始，知道这个是个数组了，那么前面的就是说明数组元素的类型了，类型是int * **

int (*p3)[6];

**首先，p3开始，加个* 表示它是个指针，指针需要什么？说明指针的类型啊，类型是int [6]，说明：把p3内存块上的数当做地址的内存块是一大堆数据，意味着后面有六个内存块，放六个数据。**

在定义数组指针时需要进行降维处理，例如三维数组指针实际指向的数据
类型是二维数组，二维数组指针实际指向的数据类型是一维数组，一维数组指针实际指向的是一个基本类型；在表达式中，数组名也会进行同样的转换。下降一维。

* int (*p4)(int, int);从 p4 开始理解，( ) 的优先级最高，编译器先解析(*p4)，p4 首先是一个指针，它后边的 ( ) 说明 p4 指向的一个函数，括号中的 int, int 是参数列表，开头的 int 用来说明函数的返回值类型。整体来看，p4 是一个指向原型为 int func(int, int);的函数的指针。

  

### 结构体

结构体整体赋值仅限于定义结构体变量的时候，

在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似

> 数组在使用时，对数组的整体赋值只存在与定义数组时，结构体也是一样，对结构体的整体赋值只存在于定义结构体时。**需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储**

### 结构体数组

所谓结构体数组，是指数组中的每个元素都是一个结构体

### 结构体指针

struct Stu student;

struct Stu *p=&student;

> 结构体变量名和数组的变量名不同，数组的变量名除了sizeof,&可以做整体时，其他时候都是转化为了指针。结构体变量名不可以转化，所以前面要加&

**结构体和结构体变量是完全不同的两个东西！！！！结构体是一种数据类型，而创建变量的模板**

** **

.与->都可以访问结构体的成员，但是！！！！.与[]的优先级比* 要高！！

所以写（*p）.name 一定一定要加括号！！

**我觉得搞清楚指针，无非搞清楚这个指针是哪个内存块的地址，而这个指针的加加代表什么**

### 结构体指针作为函数参数

**结构体变量代表整个集合本身，在向函数传递参数时，不会像数组那样转化为指针，而是整个整体都传进去，所以如果结构体变量的成员有的是数组，你传递拷贝给函数形参的开销非常大，所以正确的做法是，传结构体的指针进去，向形参传递一个地址进去无疑是最方便，最高效的一种方式了。**

如何知道结构体数组中元素的个数，int arr[]你会求元素个数吗？sizeof（arr）/sizeof(int)，

同理，结构体数组的元素个数，sizeof(arr)/sizeof(struct Stu),

通过指针你访问结构体成员有两种方式，（*p）.name

当然还可以是p->name

### 枚举（Enum）类型，

能够列出所有可能的取值，并给它们取一个名字

enum week{ Mon,Tues}

Mon与Tues是值的名字，没有给他们赋值，当没有给值赋值时他们默认从0开始。

enum week{ Mon=1,Tues=2}

enum  week a=Mon;定义a这个变量时给它赋值，拿什么赋值，拿值的名字赋值。enum 类型就是规定某个变量只能取这个范围里面的值，还有一点是你可以拿名字给变量赋值。

**枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量**

*  Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。就是你用enum定义时，相当于里面进行的是常量的赋值。而且！！！这些常量往往在main范围里是全局影响的，所以你在main里就不能再定义同名的标识符了。
* Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量

**枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值**

**Mon、Tues、Wed 这些名字都被替换成了对应的数字**

> Mon、Tues、Wed 等都不是变量，它们不占用
> 数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面

**而是直接被编译到命令里面，放到代码区，所以不能用&取得它们的地址。这就是枚举的本质。**

这里我们会思考：为什么case后面可以是一个符号，不是只能为整数吗？这是因为在编译是，Mon已经被替换为了整数，所以才能够把他们放在case后面。

**枚举类型变量需要存放的是一个整数，我猜测它的长度和 int 应该相同，下面来验证一下：

```
#include <stdio.h>2.3. int main(){

enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day = Mon;

printf("%d, %d, %d, %d, %d\n", sizeof(enum week), sizeof(day), sizeof(Mon), sizeof(Wed), 
sizeof(int) );


```

return 0;

运行结果：
4 4 4 4 4确实是int类型