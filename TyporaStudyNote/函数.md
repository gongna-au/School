# 函数

#### 函数不能嵌套定义，但可以嵌套调用，也就是在一个函数的定义或调用过程中允许出现对另外一个函数的调用.

**这句话很重要是因为，一个函数我在定义时，它里面不能定义其他函数，但是如果还有一个在这个函数外面定义好的函数，我可以在这个函数里面调用它，不可以嵌套定义，但是可以 ： **

* **定义时调用**
* **调用时调用**

**为什么可以这么做？**

* 如果一个函数 A() 在定义或调用过程中出现了对另外一个函数 B() 的调用，那么我们就称 A() 为主调函数或主函数，称 B() 为被调函数
* 当主调函数遇到被调函数时，主调函数会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回主调函数，主调函数根据刚才的状态继续往下执行

一个 C 语言程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条。
这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如 return 0;）
来结束自己的生命，从而结束整个程序。

函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码，当遇到函数调用时，CPU 首先要记
录下当前代码块中下一条代码的地址（假设地址为 0X1000），然后跳转到另外一个代码块，执行完毕后再回来继续执行 0X1000 处的代码。整个过程相当于 CPU 开了一个小差，暂时放下手中的工作去做点别的事情，做完了再继续刚才的工作

**在所有函数之外进行加减乘除运算、使用 if...else 语句、调用一个函数等都是没有意义
的，这些代码位于整个函数调用链条之外，永远都不会被执行到**

* 最后再补充一点，函数原型给出了使用该函数的所有细节，当我们不知道如何使用某个函数时，需要查找的是它的原型，而不是它的定义，我们往往不关心它的实现

在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数
中定义的变量。main 函数也是一个函数，与其它函数地位平等。

**实参给形参传值的过程也就是给局部变量赋值的过程**

**在函数的嵌套调用中，这里指的是：定义中调用，或者调用中调用，如果是在定义中调用，思考传进去的形参给了谁？形参是作为控制循环变量，还是作为给内部的函数的参数，考虑：每次调用时，内部的函数拿到的参数一不一样？内部函数拿到的参数来自哪里？参数变或不变？在写函数时，无非考虑这么几点，需要什么参数？这个需要的参数是用来干嘛的？有些参数传进去就是用来条件控制的，或者拿参数进行计算。**

 **可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆**。

在语句块中也可定义变量，它的作用域只限于当前语句块

**C 语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来**

```
#include <stdio.h>
int n = 10; //全局变量
void func1(){
    int n = 20; //局部变量
    printf("func1 n: %d\n", n);
}
void func2(int n){
    printf("func2 n: %d\n", n);
}  
void func3(){
    printf("func3 n: %d\n", n);
}
int main(){
    int n = 30; //局部变量
    func1();
    func2(n);
    func3();
    //代码块由{}包围
 { 
    int n = 40; //局部变量
    printf("block n: %d\n", n);
    } 
    printf("main n: %d\n", n);
    return 0;
}
```

运行结果：
func1 n: 20
func2 n: 30
func3 n: 10
block n: 40
main n: 30

func3() 输出 10，使用的是全局变量,是在全局变量里面去找的

函数的寻找步骤：

* 我看看我内部有没有定义并且有值，如果有，那么外部的自动屏蔽。

* 内部没有这个变量的定义与值，我去函数外部找，也就是全局变量中去找。注意这里不是main函数的局部变量中去找，main函数与其他函数同样等价，只不过因为程序是从main函数开始，所以我们在main函数里调用其他函数。

* 注意这里 的寻找和函数传参区分开

* func2 n: 30是因为int n = 30; //局部变量

  ```
  void func2(int n){
      printf("func2 n: %d\n", n);
  }  把main 函数里的n=30直接是传到函数里面赋值给形参，形参就是func2函数内部的变量！！！！
  
  
  
  如果你把main函数里的n=30注释掉，func2调用结果为10！！！
  ```

  ```
  #include <stdio.h>
  int n = 10; //全局变量
  void func1(){
      int n=1 ; //局部变量
      printf("func1 n: %d\n", n);
  }
  void func2(int n){
      printf("func2 n: %d\n", n);
  }  
  void func3(){
      printf("func3 n: %d\n", n);
  }
  int main(){
      /* int n = 30; //局部变量 */
     /*  func1(); */
      func2(n);
      /* func3(); */
      //代码块由{}包围
   { 
      int n = 40; //局部变量
      printf("block n: %d\n", n);
      } 
      printf("main n: %d\n", n);
      return 0;
  }
  ```

  

* 步骤是：func1，我自己函数内部有，我屏蔽外面的

* func2我需要一个形式参数，我去外面寻找，main里面有，用main里面的

* func3我自己内部没有，去全局变量找

  **有形参的，从内向外找**

  **无形参的，直接去全局变量找**

  ​    

  > 根据题意，我们希望借助一个函数得到三个值：体积 v 以及三个面的面积 s1、s2、s3。遗憾的是，C 语言中的函数只能有一个返回值，我们只能将其中的一份数据，也就是体积 v 放到返回值中，而将面积 s1、s2、s3 设置为全局变量。全局变量的作用域是整个程序，在函数 vs() 中修改 s1、s2、s3 的值，能够影响到包括 main() 在内的其它函数。

**有时候，我们在调用一个函数时，希望函数一次性给我们返回多个值，但是C语言里函数做不到，那么我们应该怎么做？**

**答：定义全局变量，在main函数外面的那种，然后在函中修改他们的值！！所以在main函数中调用printf才能把S2的值打出来。**

**在 vs() 中将求得的面积放到 s1、s2、s3 中，在 main() 中能够顺利取得它们的值，这说明：在一个函数内部修改**
**全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次**
**被修改。**

**全局变量也是变量，变量只能保存一份数据，一旦数据被修改了，原来的数据就被冲刷掉了，再也无法恢复了，所**
**以不管是全局变量还是局部变量，一旦它的值被修改，这种影响都会一直持续下去，直到再次被修改**

在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允
许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：

* 不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；
* 函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域

**每个 C 语言程序都包含了多个作用域，不同的作用域中可以出现同名的变量，C 语言会按照从小到大的顺序、一层
一层地去父级作用域中查找变量，如果在最顶层的全局作用域中还未找到这个变量，那么就会报错**

### 递归的进入

**1) 求 5!，即调用 factorial(5)。当进入 factorial() 函数体后，由于形参 n 的值为 5，不等于 0 或 1，所以执行
factorial(n-1) * n，也即执行 factorial(4) * 5。为了求得这个表达式的结果，必须先调用 factorial(4)，并暂停其他操作。换句话说，在得到 factorial(4) 的结果之前，不能进行其他操作。这就是第一次递归。**

**2) 调用 factorial(4) 时，实参为 4，形参 n 也为 4，不等于 0 或 1，会继续执行 factorial(n-1) * n，也即执行
factorial(3) * 4。为了求得这个表达式的结果，又必须先调用 factorial(3)。这就是第二次递归**。

**3) 以此类推，进行四次递归调用后，实参的值为 1，会调用 factorial(1)。此时能够直接得到常量 1 的值，并把结
果 return，就不需要再次调用 factorial() 函数了，递归就结束了**

**递归的关键是什么？**

**答：递归的关键在与你最后一次递归，是要能得到一个结果！！** **你要是得不到结果，你前面几次一次一次进入的递归都就还停止在那里等待结果，无法得到最终的结果。**

**递归的本质是，一次一次进入递归，直到某次不需要递归，并能得到返回值，然后开始一层一层往外当递归进入到最内层的时候，递归就结束了，就开始逐层退出了，也就是逐层执行 return 语句**

**分析的时候，你要分析的是，需要等待的结果是什么？实参是什么？**

**需要等待的值，就是你退出内层递归时要返回的值**

#### **要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题**

* **存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束**
  **了。** 也就是进行到某一刻递归就停止了！！
* **每次递归调用之后越来越接近这个限制条件**，**如何才能让每次调用递归后越来越接近接近这个限制条件？改变实参？实参又是怎么被改变的？**
* 对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n 的值逐渐减小，越来越趋近于 1 或 0。也就是说，n是限制条件，相当于for（）中的表达式2，进行条件判断，而n-1for循环中的表达式3，起到越来越接近限制条件的作用！！！！

**有参数的函数，里面好像进行着循环，有结束条件，有改变变量，让它越来越接近结束条件，当把变量改变作为参数时就变成了递归！！！递归就意味着要等待计算结果，为了得到计算结果，你就要返回计算结果，而且除最后一次结束向内递归时返回确定的结果，其他你都是返回带函数的结果！！！尾递归在逐层退出时除了 return 语句一般不再执行其他操作**

#### 中间递归



```
#include <stdio.h>#include <string.h>
//反转（逆置）字符串
char *reverse(char *str) {
	int len = strlen(str); 
	if (len > 1) {
	char ctemp = str[0]; 
	str[0] = str[len - 1]; 
	str[len - 1] = '\0'; 
//最后 reverse(str + 1); 
//递归调 str[len - 1] = ctemp; 
} 
	return str;
}
int main() { 
	char str[20] = "123456789";
	printf("%s\n", reverse(str));
	return 0;
}
```



* 每次调用函数，都会把字符串的第 0 个字符保存到 ctemp 变量，并把最后一个字符填充到第 0 个字符的位置，同时用'\0'来填充最后一个字符的位置。



* 读者要注意第 11 行代码，调用 reverse() 的实参为 str+1，这会导致形参 str 的指向发生改变，每次递归调用时 str 都会向后移动一个字符的位置



**reverse() 的整体思路是，每次调用函数只交换字符串开头和末尾的两个字符，其它字符一律不管，并且这个交换过程也是分两个阶段完成的：**

* **在逐层进入递归的阶段，reverse() 只是把字符串的最后一个字符移动到最前边，但是并没有把最前边一个字符移动到最后边，而是把最前边的字符保存到 ctemp 变量。**
* **在逐层退出递归的阶段，reverse() 才把 ctemp 变量中保存的字符放到字符串的最前边。**

你看，对于中间递归来说，它在进入和退出递归的两个阶段都会进行一些操作，而对于尾递归，它只会在进入
递归的阶段进行一些操作，退出递归的阶段不进行任何操作，这就是中间递归和尾递归的不同。

**我觉得递归调用里面最核心最核心的思想是，你把你写的代码，拆分成几个大块，然后这几个大块在每一个递归里都执行，比如上面这个代码，计算数组长度，判断，每一部分都取temp值，都赋值！都交换！！！，那么你要思考我把我结束的条件放在哪里？当我在进入下一次递归前我更改了某个变量（这里的更改指的是i++这种更改，不是赋值）后，每次递归里面都在更改，你外层递归的更改，导致每次递归的起点不同，变量啊兄弟，不是说arr[0],不是说一个数组，它下标不变，它就不变，每一次的调用都是“重生”你传进去的参数在不断的变化，就算下标不变，它数组本身也在变化啊兄弟！！**

**就像我if（len>1）,前面多少次都不起作用，就是为了结束我进入最后一次递归，那么我怎么趋近结束呢？我肯定要往递归里传了str的改变，这个的改变就是Str+1，又因为我要对str进行交换操作，但是因为我往递归里传了str的改变，所以递归中对于str的计算，判断，赋值，交换，其实都相当于是对一个变量在操作，因为它每一次都不一样。这才有了对str[0]的深刻理解！！**

**吐血总结！！！！在内部递归前的代码，之前的行为（计算，判断TODO1等等）每次递归都会进行，往内部递归传进去的参数，若在TODO1里有对这些参数的操作，注意，每一次递归都不同，他们相当于是变量，在TODO2 部分的代码意味着可以拿递归的结果来干一些事情。**

```
int 函数1（参数1）{
	
	TODO1；
	函数1（参数1的改变）
	TODO2；



}注意TODO1部分所做的计算，判断什么的，我们把它当做是为函数1（参数1）{}所准备的原材料。
当然不否认TODO1可以做一些操作，影响函数1（参数1的变化）{}
TODO1  做的计算，得到的结果这些东东，我们都认为是给函数1（参数1）{}准备原材料，每一部分的递归有每一部分的原材料，每一部分的原材料都会一捆一捆的存放着。
不存在有同一个变量a的值，通过递归不断的被更新。

这里的Ctemp就是最好的证明！！！！
```

### 为了演示由于栈溢出而导致程序崩溃的情形，下面我们用递归的方式来求 1+2+3+ ...... + (n-1) + n 的值

```
#include <stdio.h>
long sum(int n) { 
//为了增加每次函数调用的内存 
int arr[250]; 
if (n <= 1) {
	return n; 
 }else { 
	return n + sum(n-1); 
	}
}
int main() {
	printf("从 1 加到 1000 的值为  return 0;
}
这是因为，每次递归调用都需要超过 1KB 的内存（仅仅数组就占用了 1KB 内存），而要得到最终的结果需要
1000 次递归调用，这样一来，所有内存的总和就超过了 1MB。
上面我们说过，Visual Studio 默认的栈内存只有 1MB，超过这个界限程序就无法运行了，只能让它崩溃。使
用其它的编译器也许程序不会崩溃，读者可以亲自尝试
```

