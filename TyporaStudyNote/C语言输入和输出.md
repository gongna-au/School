1. scanf() 对输入数据之间的空格的处理比较宽松，并不要求空格数严格对应，多几个少几个无所谓，只要有空格就行。
2. scanf() 的控制字符串为`"%d, %d, %d"`，中间以逗号分隔，所以输入的整数也要以逗号分隔。
3. scanf("%d is bigger than %d", &a, &b) scanf() 要求整数之间以`is bigger than`分隔;

本质上讲，用户输入的内容都是字符串，scanf() 完成的是从字符串中提取有效数据的过程。

## 连续输入

```
#include <stdio.h>
int main()
{
    int a = 0, b = 0, c = 0, d = 0;
    scanf("%d", &a);  //输入整数并赋值给变量a
    scanf("%d", &b);  //输入整数并赋值给变量b
    printf("a+b=%d\n", a+b);  //计算a+b的值并输出
    scanf("%d %d", &c, &d);  //输入两个整数并分别赋值给c、d
    printf("c*d=%d\n", c*d);  //计算c*d的值并输出

    return 0;
}
```

运行结果：
12↙
60↙
a+b=72
10 23↙
c*d=230

将四个变量的值一次性输入

12 60 10 23↙
a+b=72
c*d=230

第一个 scanf() 读取完毕后没有抛弃多余的值，而是将它们保存在了某个地方，下次接着使用。

---------------

如果我们多输入一个整数，会怎样呢

12 60 10 23 99↙
a+b=72
c*d=230

发现 scanf() 仍然能够正确读取，只是 99 没用罢了。

-----

如果我们少输入一个整数，又会怎样呢？

12 60 10↙
a+b=72
23↙
c*d=230

输入三个整数后，前两个 scanf() 把前两个整数给读取了，剩下一个整数 10，而第三个 scanf() 要求输入两个整数，一个单独的 10 并不能满足要求，所以我们还得继续输入，凑够两个整数以后，第三个 scanf() 才能读取完毕。

**从本质上讲，我们从键盘输入的数据并没有直接交给 scanf()，而是放入了缓冲区中，直到我们按下回车键，scanf() 才到缓冲区中读取数据。如果缓冲区中的数据符合 scanf() 的要求，那么就读取结束；如果不符合要求，那么就继续等待用户输入，或者干脆读取失败**



**这说明 scanf() 不会跳过不符合要求的数据，遇到不符合要求的数据会读取失败，而不是再继续等待用户输入**

**总而言之，正是由于缓冲区的存在，才使得我们能够多输入一些数据，或者一次性输入所有数据，这可以认为是缓冲区的一点优势。然而，缓冲区也带来了一定的负面影响，甚至会导致很奇怪的行为，请看下面的代码：**

```
#include <stdio.h>
int main()
{
    int a = 1, b = 2;
    scanf("a=%d", &a);
    scanf("b=%d", &b);
    printf("a=%d, b=%d\n", a, b);

    return 0;
}
```

输入示例：

a=99↙
a=99, b=2

输入`a=99`，按下回车键，程序竟然运行结束了，只有第一个 scanf() 成功读取了数据，第二个 scanf() 仿佛没有执行一样，根本没有给用户任何机会去输入数据。


如果我们换一种输入方式呢？

a=99b=200↙
a=99, b=200

这样 a 和 b 都能够正确读取了。注意，`a=99b=200`中间是没有任何空格的。

肯定有好奇的小伙伴又问了，如果`a=99b=200`两个数据之间有空格又会怎么样呢？我们不妨亲试一下：

a=99 b=200↙
a=99, b=2

你看，第二个 scanf() 又读取失败了！在前面的例子中，输入的两份数据之前都是有空格的呀，为什么这里不能带空格呢，真是匪夷所思。好吧，这个其实还是跟缓冲区有关系，我将在《[结合C语言缓冲区谈scanf()函数](http://c.biancheng.net/cpp/html/3101.html)》中深入讲解。

请看下面的例子：

```
#include <stdio.h>
#include <stdlib.h>
int main()
{
int a, b, c;
scanf("%d", &a);
scanf("%d", &b);
scanf("%d", &c);
printf("a=%d, b=%d, c=%d\n", a, b, c);
system("pause");
return 0;
}
```

运行结果：
100 200 300↙
a=100, b=200, c=300

程序执行到第一个 scanf()，由于缓冲区中没有数据，所以会等待用户输入。从键盘输入`100 200 300`后按下回车键，输入就结束了，scanf() 开始从缓冲区中读取数据。由于控制字符串是`"%d"`，所以它会读取一个整数，这里匹配到的整数是100。接下来将100赋值给变量 a，并将100从缓冲区中删除，此时缓冲区中剩下`200 300`。

**注意：scanf() 匹配到想要的数据后，会将匹配到的数据从缓冲区中删除，而没有匹配到的数据仍然会留在缓冲区中。**

再来看一个例子：

```

#include <stdio.h>
#include <stdlib.h>
int main()
{
int a, b=999;
char str[30];
printf("b=%d\n", b);
scanf("%d", &a);
scanf("%d", &b);
scanf("%s", str);
printf("a=%d, b=%d, str=%s\n", a, b, str);
 
system("pause");
return 0;

```

运行结果：
b=999
100 c.biancheng.net↙
a=100, b=999, str=c.biancheng.net

**程序执行到第一个 scanf() 时等待用户输入。从键盘输入`100 c.biancheng.net`，按下回车键，scanf() 匹配到100，赋值给变量a，同时将100从缓冲区中删除。**

**执行到第二个 scanf() 时，缓冲区中有数据，会直接读取。由于此时缓冲区中的内容为 c.biancheng.net，并不是 scanf() 想要的整数，所以匹配失败，不会给变量b赋值，这就是两次输出变量b的值相同的原因。匹配失败也意味着不会从缓冲区中删除任何数据。**



**最最最关键的一点是scanf从缓冲区中进行匹配时，匹配失败将不会给变量赋值，也就意味着不会从缓冲区中删除任何数据，这就是两次输出变量b的值相同的原因。执行到第三个 scanf() 时，缓冲区中的内容仍然是 c.biancheng.net，明显是字符串，所以匹配成功并赋值给 str。**

**值得一提的是，在控制台中输入的任何内容本质上都是字符串，都会被`%s`所匹配。对于上面的程序，不妨换成下面的输入内容：**



b=999
100 200 300↙
a=100, b=200, str=300

看，300 也被 %s 匹配成功。

**scanf在用%s从缓冲区获取数据时，不论输入的是什么，往往都能匹配，因为输入到缓冲区的数据本质上是已字符串的形式输入，所以，当缓冲区里我们多输入一些数据，或者是前面的scanf因为格式化输入等等一些问题，导致匹配失败，匹配失败则不会从缓冲区删除任何数据，那么这些数据将保留下来，对后面的scanf进行影响，这个时候往往用到fflush()来清除缓冲区的原因。 **

## 缓冲区引发的问题

缓冲区虽然能够让输入更加方便，但有时也会引发奇怪的问题。例如：

```
#include <stdio.h>
#include <stdlib.h>
int main()
{
int a=0, b=0;
scanf("a=%d", &a);
scanf("b=%d", &b);
printf("a=%d, b=%d\n", a, b); 
system("pause");
return 0;
}
```

运行结果：
a=100↙
a=100, b=0

**遇到第一个 scanf()，输入`a=100`并回车，就会将100赋值给a，并将`a=100`从缓冲区中删除。遇到第二个 scanf() 时，缓冲区中不是没有内容了吗，为什么不会等待用户输入**

**其实当用户按下回车键时，回车换行符也会被保存到缓冲区，只是大多数情况下 scanf() 会忽略，前面的两个例子就是这样。但是当控制字符串不是以 %xxx 开头时，回车换行符就起作用了，scanf() 会对它进行匹配，只是匹配失败而已。该例中第二个 scanf() 就是匹配回车换行符失败，所以既不等待用户输入，也不给b赋值。**

将第二个 scanf() 的控制字符串改成下面的样子：

```
scanf("%d", &b);
```

运行结果：
a=100↙
200↙
a=100, b=200



此时 scanf() 就会忽略缓冲区中的回车换行符，等待用户输入。

总结：在大多数情况下，**回车换行符在scanf匹配时被忽略，但是也只是大多数情况下，如果，当格式化输入不是以%d这种开头，而是“a=%d”这种，这个时候就会匹配失败，不会给a赋值，程序就会继续往下跑，如果后面再没有scanf这个，那么就结束了，**

如果源程序不改变，还是这个代码，我怎么输如，才能不报错。

```
#include <stdio.h>
#include <stdlib.h>
int main()
{
int a=0, b=0;
scanf("a=%d", &a);
scanf("b=%d", &b);
printf("a=%d, b=%d\n", a, b);
system("pause");
return 0;
}
```

情况1：键盘中输入：

a=100b=200↙

a=100,b=200

情况2:键盘中输入：

a=100 b=200

a=100,b=2

**注意没有空格，因为空格也就起作用了，然后scanf就会把空格与b=%d做匹配，匹配失败**

### 对于 scanf(),输入数据的格式要和控制字符串的格式保持一致的理解

**scanf() 有两个以空格分隔的%d,后面还跟着两个变量,这要求我们一次性输入两个整数,并分别**
**赋值给 c 和 d。注意"%d %d"之间是有空格的,所以输入数据时也要有空格**

但是！！！

```
#include<stdio.h>

int main(){
int a, b, c;
scanf("%d %d", &a, &b);

printf("a+b=%d\n", a + b);
scanf("%d
%d", &a, &b);

printf("a+b=%d\n", a + b);

scanf("%d, %d, %d", &a, &b, &c);

printf("a+b+c=%d\n", a + b + c);

scanf("%d is bigger than %d", &a, &b);

printf("a-b=%d\n", a - b);

return 0;}
```

运行结果:

```
10
20↙
a+b=30
100 200↙
a+b=300
56,45,78↙
a+b+c=179
25 is bigger than 11↙
a-b=14
```

**第一个 scanf() 的格式控制字符串为"%d %d",中间有一个空格,而我们却输入了 10
20,中间有多个空格。第二
个 scanf() 的格式控制字符串为"%d %d",中间有多个空格,而我们却输入了 100 200,中间只有一个空格。这说
明 scanf() 对输入数据之间的空格的处理比较宽松,并不要求空格数严格对应,多几个少几个无所谓,只要有空格
就行。**

注意：是只要有空格就行，虽然scanf对于空格不怎么敏感，但是若scanf("%d   %d"，&a,&b)，你在输入时，不输空格不行，至于输入的空格是几个无所谓,**只要有空格就行**

### 输入其它数据

### 对读取字符串的说明

```
char str1[] = "http://c.biancheng.net";
char *str2 = "C 语言中文网";
```

**这两种形式其实是有区别的,第一种形式的字符串所在的内存既有读取权限又有写入权限,第二种形式的字符串所**
**在的内存只有读取权限,没有写入权限**

### 字符串的表示

```
char str1[] = "http://c.biancheng.net";
char *str2 = "C 语言中文网";
```



**另外,对于第一种形式的字符串,在[ ]里面要指明字符串的最大长度,如果不指明,也可以根据=后面的字符串来
自动推算,此处,就是根据"http://c.biancheng.net"的长度来推算的。**





```
char str[];

```

但是如果我们只是定义了一个字符串,并没有立即给它赋值,所以没法自动推算,只能手动指明最大长度,这也就是为什么一定要写作 char str[30],而不能写成为char str []

# 数组和指针绝不等价，数组是另外一种类型

数组和指针不等价的一个典型案例就是求数组的长度，这个时候只能使用数组名，不能使用数组指针，前面我们已经强调过了，这里不妨再来演示一下：

```
#include <stdio.h>
 
int main(){
    int a[6] = {0, 1, 2, 3, 4, 5};
    int *p = a;
    int len_a = sizeof(a) / sizeof(int);
    int len_p = sizeof(p) / sizeof(int);
    printf("len_a = %d, len_p = %d\n", len_a, len_p);
    return 0;
}

```

运行结果：

len_a = 6, len_p = 1

**数组是一系列数据的集合，没有开始和结束标志，p 仅仅是一个指向 int 类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 p 使用 sizeof 求得的是指针变量本身的长度。也就是说，编译器并没有把 p 和数组关联起来，p 仅仅是一个指针变量，不管它指向哪里，sizeof 求得的永远是它本身所占用的字节数。**

> **站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度**

这句话简直绝绝子！！！！

> 站在哲学的高度看问题
> 编程语言的目的是为了将计算机指令（机器语言）抽象成人类能够理解的自然语言，让程序员能够更加容易地管理和操作各种计算机资源，这些计算机资源最终表现为编程语言中的各种符号和语法规则。
>
> 
>
> 整数、小数、数组、指针等不同类型的数据都是对内存的抽象，它们的名字用来指代不同的内存块，程序员在编码过程中不需要直接面对内存，使用这些名字将更加方便。

**编译器在编译过程中会创建一张专门的表格用来保存名字以及名字对应的数据类型、地址、作用域等信息，sizeof 是一个操作符，不是函数，使用 sizeof 时可以从这张表格中查询到符号的长度。**

## **数组名的含义**

绝大多数情况，数组名都代表着指向该数组中下标为0的元素的指针，但是有例外：

```
int e[4];//假设int为4字节
sizeof(e);
```

上面的sizeof(e)的值并非4或8（指针占用空间），而是4*4 = 16。也就是说，当数组名被用作运算符sizeof的参数时，它的计算结果是**整个数组的大小**，而非第一个元素的指针大小。
再来看下面这种情况：

```
int temp[5];
&temp+1;
temp+1;
```

在这里，&temp指向整个数组，因此+1后指向了数组末尾，而temp指向数组第一个元素，+1后指向第二个元素。

我们在求数组长度时：

```
#include <stdio.h>

int main(){
    int a[6] = {0, 1, 2, 3, 4, 5};
    int *p = a;
    int len_a = sizeof(a) / sizeof(int);
    int len_p = sizeof(p) / sizeof(int);
    printf("len_a = %d, len_p = %d\n", len_a, len_p);
    return 0;
}
```

运行结果：

len_a = 6, len_p = 1

>  **数组是一系列数据的集合，没有开始和结束标志，p 仅仅是一个指向 int 类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 p 使用 sizeof 求得的是指针变量本身的长度。也就是说，编译器并没有把 p 和数组关联起来，p 仅仅是一个指针变量，不管它指向哪里，sizeof 求得的永远是它本身所占用的字节数。**

对数组名a使用sizeof（a）得到的永远是数组所占的字节数，但是我们还知道，数组也可以代表一个指向第一个数据下标为0的指针，但是sizeof（）计算出来的不是这个指针的字节数，（这与sizeof这个操作符在内存中建立的一张表有关）

**接着说这里的&temp对这个数组名取地址，同理和sizeof一样，它还是代表的是整个数组，&temp指向整个数组，因此+1后指向了数组末尾，那数组的第二个元素怎么表示：当然是temp+1啦，temp指向数组第一个元素，+1后指向第二个元素。temp[1]等价于 *（temp+1）**

## **不能作为参数的数组**

**所谓的数组不能作为参数，并不是指声明的数组不能作为参数传递**

这句话的意思是：

```
int f[] = {1,2,3,4,5,6};
int *g = f;
```

这里数组就是当参数传递呀



**所谓的数组不能作为参数，并不是指声明的数组不能作为参数传递，而是指当数组名作为参数时，数组名会被转换为指向该数组下标为0的元素的指针。**

**或者这么理解int *g = f本质上不就是指针=指针，这个时候，数组名就转化为了指向下标为零元素的指针！！！！**

```
size_t arrayLen(const int *arr);
size_t arrayLen(const int arr[]);
```





## **不能作为参数的数组**

所谓的数组不能作为参数，并不是指声明的数组不能作为参数传递，而是指当数组名作为参数时，数组名会被转换为指向该数组下标为0的元素的指针。
而下面的两种声明，其实也是等效的：

```text
size_t arrayLen(const int *arr);
size_t arrayLen(const int arr[]);
```

我们来看一个例子，说明数组作为参数的情况：

```text
#include <stdio.h>
int arraySum(const int arr[])
{
    unsigned int loop = 0;
    /*循环前计算好长度，提高性能*/
    unsigned int len = sizeof(arr)/sizeof(int);
    int sum = 0;
    if(NULL == arr)
    {
        return 0;
    }
    for(loop = 0; loop < len; loop++)
    {
        sum+=arr[loop];
    }
    return sum;   
}
int main(void)
{
    int a[] = {1,2,3,4,5,6};
    int sum = arraySum(a);
    printf("arr sum is %d",sum);
    return 0;
}
```

我们运行上面的程序，发现最终结果并不是我们预期的21，而是3。问题在于，a作为参数传入到arraySum中时，它是作为指针的，那么在函数内部计算sizeof(arr)自然只是得到了指针占用的内存大小。对于64位程序，这个大小是8，那么len的值为2，最终只计算了两个元素的和。

思考：该如何修改上面的程序才能得到正确的结果？

答：先在main里面用sizeof把数组长度取出来，再用参数的形式传进arraySum方法里面

分析如下：！！！！！！！！！！

**解答是：我们定义了一个函数，并在这个函数里计算数组的长度，但是如果这个数组是一个外界的数，需要通过传到这个函数里，那么就会产生错误，错误是，当我们把数组当做参数传进来时，实际上因为数组名会被转换为指向该数组下标为0的元素的指针，所以传进来的是数组下标为1的指针，当然不能在我们定义的函数里计算出这个数组的长度！！！！重要！！！！千万分重要！！！**



上述表达存在的一些小问题：

> 1 数组名并不是说“代表”了第一个元素的指针，数组和元素指针在语法和类型系统上都是两码事，严格说是“数组名在大部分情景下会隐式转换为其元素的指针类型，值为第一个元素的地址”
>
> 2 数组名的确不能++，但它是左值，左值是看一个表达式是否能被取地址，但左值不一定就能做赋值运算，C是有const左值的概念的

**数组名在大部分情景下会隐式转换为其元素的指针类型，值为第一个元素的地址”**

一个数组a ,a+1这种表达到底对不对**本质上是要看它以什么身份出现**，若以指针出现，当然无可厚非，但是作为数组，就不可以！！！！！

# 数组到底在什么时候会转换为指针

> 数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身，这在前面的例子中已经被多次证实。
>
> 数据集合包含了多份数据，直接使用一个集合没有明确的含义，将数组名转换为指向数组的指针后，可以很容易地访问其中的任何一份数据，使用时的语义更加明确。

!!!!!我草我草,下面这句话这句话yyds!!!!**C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 & 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）。**

多么精！！！当数组名作为数组定义的标识符，定义或声明数组时，sizeof或者&的操作数时，才代表整个数组本身！！！！，在其他表达式中数组名都会转化为指向第0个元素的指针！！！！！

## 再谈数组下标[ ]

C语言标准还规定，数组下标与指针的偏移量相同。通俗地理解，就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。假设现在有一个数组 a 和指针变量 p，它们的定义形式为：

int a = {1, 2, 3, 4, 5}, *p, i = 2;

访问a[i]的三种方式：

```
p = a;
p[i];
```



```
p = a;
*(p + i);
```



```
p = a + i;
*p;
```

### 取下标操作符[]的本质

**取下标操作符 `[ ]`是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为 `T *`，所产生的结果的类型就是 `T`。**

使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组 a 中每个元素都是 int 类型，长度为 4 个字节，那么 `a[i+1]`和 `a[i]`在内存中的距离是 4（而不是 1）。



## 数组作函数参数

**C语言标准规定，作为“类型的数组”的形参应该调整为“类型的指针**

这句话简直绝绝子！！！！

**在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第 0 个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝**

也就是说，C语言标准规定，编译器往函数传数组就是要把类型的数组转化为类型的指针，往函数传数组第0个下标的指针，而不是传整个数组的拷贝。

这种隐式转换意味着下面三种形式的函数定义是完全等价的：

```
void func(int* parr){....}

void func(int arr[]){....}

void func (int arr[4]){....}
```

**在函数内部，arr 会被转换成一个指针变量，编译器为 arr 分配 4 个字节的内存，用 sizeof(arr) 求得的是指针变量的长度，而不是数组长度。要想在函数内部获得数组长度必须额外增加一个参数**

> 比如我们定义了一个函数，在函数内部有个循环，循环的条件就是数组的长度，那么这个长度我们只能在往这个函数里再加一个参数，这个参数就是我们需要的数组长度，作为函数的参数的数组的长度只能在函数的外面进行计算，因为，你往函数里传进去的数组都是指针的形式，你sizeof（一个指针）和sizeof（数组）完全不同好嘛！！！！！



----



> 把作为形参的数组和指针等同起来是出于效率方面的考虑。数组是若干类型相同的数据的集合，数据的数目没有限制，可能只有几个，也可能成千上万，如果要传递整个数组，无论在时间还是内存空间上的开销都可能非常大。而且绝大部分情况下，我们其实并不需要整个数组的拷贝，我们只想告诉函数在那一时刻对哪个特定的数组感兴趣。

我们来总结一下前面的核心内容：

- 数组下标运算实际上都是通过指针进行的。

- 数组名代表着指向该数组中下标为0的元素的指针，但有例外：sizeof(数组名)返回整个数组的大小，而非指针大小；&数组名返回一个**指向数组的指针**，而不是指向该数组中下标为0的元素的指针的指针。

  ```
  #include<stdio.h>
  int main(void)
  {
  
      int a[5] = {1,2,3,4,5};
      int *p = (int*)(&a+1);
      printf("%d,%d",*(a+1),*(p-1));
      return 0;
  }
  
  在这里(int*)(&a+1)的这个就是最好的说明
  &a,一个指向数组的指针，&a+1,指向下一个内存块的指针，但是下一个内存块，你并不知道他是什么类型，进行强制类型转化，赋值给另一个int型的指针，p-1,把这个指针往前移，取这个指针所指的值。
  
  ```

  

  

- 数组名作为参数时，数组名会被转换成指向该数组下标为0的元素的指针。

- 指针操作可能比下标操作效率高，但可维护性却不一定有下标操作好。

- 数组和指针不相等。

## 关于数组和指针可交换性的总结



* 用 a[i] 这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像 *(a+i) 这样的指针形式。
* **指针始终是指针，它绝不可以改写成数组。**你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组
* 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针
* 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。

# scanf无法读取含有空格的字符串

scanf() 读取字符串时以空格为分隔,遇到空格就认为当前字符串结束了,所以无法读取含有空格的字符串,请看下面的例子:

```
#include <stdio.h>
int main(){
	char author[30], lang[30], url[30];
	scanf("%s %s", author, lang);
 	printf("author:%s \nlang: %s\n", author,lang);
 	scanf("%s", url);
 	printf("url: %s\n", url);
 	return 0;
 }
```



**对于含有空格的一段字符串，你知道有几个空格，你可以采用scanf（“%s   %s    %s”）这种形式读取，用一个%s你是读取不到的，因为scanf遇到空格就停止读取了。**

```
运行示例:
YanChangSheng C-Language↙
author:YanChangSheng
lang: C-Language
http://c.biancheng.net http://biancheng.net↙
url: http://c.biancheng.net

```



# 输入字符串



```
 #include <stdio.h>
 int main() {
 	char author[30], lang[30], url[30];
	 gets(author);
 	printf("author: %s\n", author);
	 gets(lang);
	 printf("lang: %s\n", lang);
	 gets(url);
	 printf("url: %s\n", url);

	return 0;
	}
```

****

运行结果

```
YanChangSheng↙
author: YanChangSheng
C-Language↙
lang: C-Language
http://c.biancheng.net http://biancheng.net↙
url: http://c.biancheng.net http://biancheng.net
```



* scanf() 读取字符串时以空格为分隔,遇到空格就认为当前字符串结束了,所以无法读取含有空格的字符串



* gets() 认为空格也是字符串的一部分,只有遇到回车键时才认为字符串输入结束,所以,不管输入了多少个空
  格,只要不按下回车键,对 gets() 来说就是一个完整的字符串。
* **也就是说,gets() 能读取含有空格的字符串,而 scanf() 不能。**

**C 语言中常用的从控制台读取数据的函数有五个,它们分别是 scanf()、getchar()、getche()、getch() 和 gets()。其**
**中 scanf()、 getchar()、 gets() 是标准函数,适用于所有平台; getche() 和 getch() 不是标准函数,只能用于 Windows。**

**scanf() 是通用的输入函数,它可以读取多种类型的数据。**
**getchar()、getche() 和 getch() 是专用的字符输入函数,它们在缓冲区和回显方面与 scanf() 有着不同的特性,是**
**scanf() 不能替代的。**

**gets() 是专用的字符串输入函数,与 scanf() 相比,gets() 的主要优势是可以读取含有空格的字符串。**
**scanf() 可以一次性读取多份类型相同或者不同的数据, getchar()、 getche()、 getch() 和 gets() 每次只能读取一份特定类型的数据,不能一次性读取多份数据。**

# 缓冲区的类型

**根据数据刷新(也可以称为清空缓冲区,就是将缓冲区中的数据“倒出”)的时机,可以分为全缓冲、行缓冲、**
**不带缓冲。这种分类才本节要重点讲解的内容。**

* 行缓冲
  在这种情况下,**当在输入或者输出的过程中遇到换行符时,才执行真正的输入输出操作**。行缓冲的典型代表就
  是标准输入设备(也即键盘)和标准输出设备(也即显示器)。

 在讲解 printf() 时,我们在 Linux 或者 Mac OS 平台测试了如下的代码:

```
#include<stdio.h>
#include<unistd.h>
 int main(){
 	printf("C 语言中文网");
 	sleep(5);
	printf("http://c.biancheng.net\n");
//程序暂停 5 秒钟
return 0;
}
```

运行程序后,会发现第一个 printf() 并没有立即输出,而是等待 5 秒以后,和第二个 printf() 一起输出了。
究其原因,就是 printf() 带有行缓冲区,"C 语言中文网"这几个字符要先放入缓冲区中,而不是立即显示到屏幕
上。放入缓冲区以后,程序又暂停了 5 秒,然后执行第二个 printf(),又将"http://c.biancheng.net\n"放入了
缓冲区。**注意最后的换行符\n,它会使得缓冲区刷新,将缓冲区中的所有内容都输出到显示器上,所以我们才**
**184看到两个 printf() 一起输出。**

如果将第一个 printf() 的最后加上换行符\n,也就是写作下面的形式:
printf("C 语言中文网\n");

此时情况又不一样了,第一个 printf() 会先输出,第二个 printf() 等待 5 秒以后才输出。这是因为,第一个
printf() 的最后有换行符\n,它会使得缓冲区刷新,所以立即就输出了,不用等着第二个 printf()

> **对于 scanf(),不管用户输入多少内容,只要不按下回车键,就不进行真正的读取。这是因为 scanf() 是带有**
> **行缓冲的,用户输入的内容会先放入缓冲区,直到用户按下回车键,产生换行符\n,才会刷新缓冲区,进行真**
> **正的读取。**

#### **对于scanf来说，你输入的过程，不是读取的过程，只有当行缓冲区刷新的时候（直到用户按下回车键,产生换行符\n,才会刷新缓冲区）才是读取的时候。printf（）遇到\n才是刷新缓冲区，输出的过程！！！！**





# **结合 C 语言缓冲区谈 scanf 函数,那些奇怪的行为其实都有章可循**



scanf() 的这些特性都是有章可循的,其根源就是行缓冲区。
当遇到 scanf() 函数时,程序会先检查输入缓冲区中是否有数据:

* 如果没有,就等待用户输入。用户从键盘输入的每个字符都会暂时保存到缓冲区,直到按下回车键,产生换行
  符\n,输入结束,scanf() 再从缓冲区中读取数据,赋值给变量。
* 如果有数据,那就看是否符合控制字符串的规则:
  如果能够匹配整个控制字符串,那最好了,直接从缓冲区中读取就可以了,就不用等待用户输入了。
* 如果缓冲区中剩余的所有数据只能匹配前半部分控制字符串,那就等待用户输入剩下的数据。
* 如果不符合,scanf() 还会尝试忽略一些空白符,例如空格、制表符、换行符等:
* 如果这种尝试成功(可以忽略一些空白符),那么再重复以上的匹配过程。
* 如果这种尝试失败(不能忽略空白符),那么只有一种结果,就是读取失败。





```
#include <stdio.h>
 int main() {
 	int a, b, c;
 	scanf("%d", &a);
	scanf("%d", &b);
	scanf("%d", &c);
 	printf("a=%d, b=%d, c=%d\n", a, b, c);

	return 0;
 }
```

运行结果:

```
100 200 300↙
a=100, b=200, c=300
```



史上最全分析！！！！！

**程序执行到第一个 scanf(),由于缓冲区中没有数据,所以会等待用户输入。从键盘输入 100 200 300 后按下
回车键,输入就结束了,scanf() 开始从缓冲区中读取数据。
第一个 scanf() 的控制字符串是"%d",会匹配到第一个整数,也就是 100,于是将 100 赋值给变量 a,并将内
部的位置标记移动到 100 以后,此时缓冲区中剩下 200 300↙。注意,换行符也是一个字符,也会进入缓冲区。
位置标记是什么?系统内部有一个专门用来记录 scanf() 读取到哪个位置的标记,随着 scanf() 的读取,该标记
会向后移动,下一个 scanf() 就从这个新的位置开始读取。
第二个 scanf() 的控制字符串也是"%d",需要读取一个整数,而此时缓冲区中的内容是 200 300↙,开头是一
个空格,并不是一个有效的数字,不符合控制字符串的规则。空格是一个空白符,此处是可以忽略的,于是
scanf() 忽略空格后再继续匹配,就得到了数字 200,终于匹配成功了。
到了第三个 scanf(),缓冲区中剩下 300↙,同样会忽略开头的空格,匹配到数字 300。
最终,三个 scanf() 都匹配成功了,缓冲区中只留下了↙。嗯,那就留着吧,已经没用了,等程序运行结束了,
会释放缓冲区内存,一切数据都灰飞烟灭了。**





# Scanf匹配失败意味着不会移动内部的位置指针



```
#include <stdio.h>
int main(){
	int a, b=999;
	char str[30];
	printf("b=%d\n", b);
	scanf("%d", &a);
	scanf("%d", &b);
	scanf("%s", str);
	printf("a=%d, b=%d, str=%s\n", a, b, str);

return 0;
 }
```



运算结果

```
b=999
100 http://c.biancheng.net↙
a=100, b=999, str=http://c.biancheng.net
```

程序执行到第一个 scanf() 时等待用户输入,从键盘输入 100 http://c.biancheng.net,按下回车键，**看到回车，好，表示往缓冲区的输入结束，然后scanf开始匹配，匹配到 100,赋值给变量 a,同时将内部的位置指针移动到 100 后面，到了第二个 scanf(),缓冲区中有数据,会直接读取，此时缓冲区中的内容为 http://c.biancheng.net↙,即使
忽略开头的空格也不是 scanf() 想要的整数，所以匹配失败了,不会给变量 b 赋值,b 的值保持不变,这就是
两次输出变量 b 的值相同的原因。，但是！！！！！！！！！**

**匹配失败意味着:"不会移动内部的位置指针"此时缓冲区中的内容仍然是 http://c.biancheng.net↙。执行到底三个 scanf() 时,它想要一个字符串,这不是正好捡漏吗,把 http://c.biancheng.net 赋值给 str 就好了。**





**还有很重要很重要的一点是!!!!!**

**实测发现,空白符在大部分情况下都可以忽略,前面的两个例子就是这样。但是当控制字符串不是以格式控制
符 %d、%c、%f (如："a=%d"这种)等开头时,空白符就不能忽略了,它会参与匹配过程,如果匹配失败,就意味着 scanf() 读取失败了。**

**第二个 scanf() 的控制字符串以%d 开头,就可以忽略换行符了忽略换行符以后,缓冲区中就没有内
容了,所以会等待用户输入。输入 200 以后,第二个 scanf() 就匹配成功了,将 200 赋值给变量 b**

输入：

```
a=100↙
200↙
a=100, b=200
```



!!!!!!!!!!!!!!!!请一定一定记住这个结论

>  **那么,为什么只有当控制字符串以格式控制符开头时,才会忽略换行符呢?我也觉得这个特性很奇怪,目前还**
> **未想明白,也没有资料可查,请读者先记住这个结论。**

# 清空输入缓冲区

两种通用的方案：

* 使用 getchar() 清空缓冲区

   getchar() 是带有缓冲区的,每次从缓冲区中读取一个字符,包括空格、制表符、换行符等空白符,只要我们让
  getchar() 不停地读取,直到读完缓冲区中的所有字符,就能达到清空缓冲区的效果。请看下面的代码:

  ```
  int c;
  while((c = getchar()) != '\n' && c != EOF);
  ```

  该代码不停地使用 getchar() 获取缓冲区中的字符,直到遇见换行符\n 或者到达文件结尾才停止。由于大家所
  学知识不足,这段代码暂时无法理解,我也就不细说了,在实际开发中,大家按照下面的形式使用即可

```
#include <stdio.h>
int main() {
	int a = 1, b = 2;
	char c;
	scanf("a=%d", &a);
	while((c = getchar()) != '\n' && c != EOF); //在下次读取前清空缓冲区
	scanf("b=%d", &b);
	printf("a=%d, b=%d\n", a, b);
	return 0;
}
```

```
a=100↙
b=200↙
a=100, b=200
```

* 使用 scanf() 清空缓冲区

  **第一个 scanf() 将逐个读取缓冲区中\n 之前的其它字符,% 后面的 * 表示将读取的这些字符丢弃,遇到\n 字符**
  **时便停止读取。此时,缓冲区中尚有一个\n 遗留,第二个 scanf() 再将这个\n 读取并丢弃,这里的星号和第一**
  **个 scanf() 的星号作用相同。由于所有从键盘的输入都是以回车结束的,而回车会产生一个\n 字符,所以将\n**
  **连同它之前的字符全部读取并丢弃之后,也就相当于清除了输入缓冲区。**

```
scanf("%*[^\n]"); scanf("%*c");
```

