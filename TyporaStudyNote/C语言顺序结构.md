* 关系运算符的运算结果只有 0 或 1。当条件成立时结果为 1,条件不成立结果为 0
* if 语句的判断条件中不是必须要包含关系运算符,**它可以是赋值表达式**,甚至也可以是一个变量

**这里为什么要强调是赋值表达式，因为赋值表达式会改变变量的值，兄弟！！！！**

**如果后续，这个被改变的值参加循环条件的判断，或者再次参与运算，打印结果，你忽略它在赋值表达式中值的改变，这不是扯蛋？后续还怎么判断程序的运行？**

```
if（a=一个我们自己定义的返回0或1的函数）{
	//ToDo


}
```

```
if (ch=getchar()){
	\\ToDo
}
```

```
if (a=3){


//Todo
}
```

**条件可以是赋值表达式，给我们提供了以下几个应用场景，调用函数返回0或1，在条件判断的同时改变某个变量的值，或者根据前面变量的值来进行判断要不要进行下面这个语句块的执行。比如说，设置标志变量啥的**

逻辑运算符和其它运算符优先级从低到高依次为:

赋值运算符<逻辑运算符<关系运算符<算数运算符<非运算符



### Switch语句

```
switch(表达式){
case 整型数值 1: 语句 1;
case 整型数值 2: 语句 2;
......
case 整型数值 n: 语句 n;
default: 语句 n+1;
}
```

**步骤如下：**

1. 计算表达式的值
2. 从第一个case开始，比较整型数值1与表达式的值，如果一样，从语句一开始执行，执行到N+1个语句，**而不管后面的 case 是否匹配成功**      **这句话很重要！！！，就是不管后面的case能不能匹配上，我全都执行！！**
3. 如果“整型数值 1”和 m 不相等,就跳过冒号后面的“语句 1”,继续比较第二个 case、第三个 case......一旦
   发现和某个整型数值相等了,就会执行后面所有的语句。假设 m 和“整型数值 5”相等,那么就会从“语句 5”一
   直执行到“语句 n+1
4. 如果直到最后一个“整型数值 n”都没有找到相等的值,那么就执行 default 后的“语句 n+1”。



**需要重点强调的是,当和某个整型数值匹配成功后,会执行该分支以及后面所有分支的语句**

**break 是 C 语言中的一个关键字,专门用于跳出 switch 语句。**

**“跳出”**是指**一旦遇到 break,就不再执行**
**switch 中的任何语句**，包括当前分支后面的语句，以及其它case后面的语句！！！

**本质核心是：整个 switch 执行结束了,接着会
执行整个 switch 后面的代码**



注意的很重要的两点！！！

> case 后面必须是一个**整数**,(这里的整数就是指**整型**，不能是小数！！)或者是结果为**整数的表达式**,但**不能包含任何变量！！！**

> 没default，所有匹配失败，啥都不干1
>
> 有default，所有匹配失败，干default里面要干的事！

### C 语言条件运算符(? :)详解

```
表达式 1 ? 表达式 2 : 表达式 3
```

值得注意的几点！！！

* **条件运算符的优先级低于关系运算符和算术运算符,但高于赋值符。**

* 条件运算符?和:是一对运算符,不能分开单独使用

* 条件运算符的结合方向是自右至左。例如

  ```
  a>b? a:c>d?c:d;
  正确解读为：先C>d?c:d这个条件表达式会有一个值，建设为X则原式为：a>b?a:x再得出条件表达式的值。
  
  ```

### while（）循环本质

**while 循环的整体思路是这样的：设置一个带有变量的循环条件，也即一个带有变量的表达式；在循环体中额外添
加一条语句，让它能够改变循环条件中变量的值。这样，随着循环的不断执行，循环条件中变量的值也会不断变化，
终有一个时刻，循环条件不再成立，整个循环就结束了。**

> while里是带变量的表达式
>
> 循环语句里加改变这个变量的赋值表达式，具体是每一次都改变，还是说给它给个条件，让它满足条件才能改变，（这样做导致，可能这个变量的同一个值被拿去做了好几次循环，那么我的这个循环条件又是怎么被改变，同一个值做好几次循环，那我的这个循环变量的值要怎么改变？循环变量的值是怎么改变？）
>
> **循环变量的值要怎么改变？循环变量的值是怎么改变？控制循环的条件除了这一个条件，还有没有别的条件？在这个条件下他们执行的是不是一样的？如果两个条件下执行的不一样，if （）  else ，它的这个执行是不是循环执行，是while，不是if ，比如有两种不同的情况，if else，但是在这两种不同的情况下又是循环执行，那么考虑while 与if嵌套等等**

要注意的很重要很重要的几点！！！

* **循环条件不成立的话，while 循环就一次也不会执行**，而每一次进行循环都要进行判断，每一次的判断，如果条件不满足就停止，while就到此结束！！！！最常见的就是while中因为条件的原因会出现，进行到某次条件判断时，因为条件不满足而导致的中断（这里的中断指的是，我本应该还要继续执行几次循环体，你他妈倒好，因为可能出现的一些情况，导致我在判断时条件不满足，而直接退出不做，导致计算结果的异常，或者程序整个的中断）。
* **时时刻刻记得有些变量的值是你要去改变的！！！！忘记改变变量值的后果是：结果错误。程序中断，异常，跳过了某些本应该要计算的步骤，一步错，步步错！！！！**



### do-while 循环

```
do{
  语句块
}while(表达式);
```

**本质是先执行一次语句，然后我再判断要不要执行下一次语句，所以说do-while 中的while（）是对下次要不要执行的判断，同样条件不满足，就不执行下次，注意是，条件不满足，不执行下次，就算某一次条件不满足，结束了，但是，在我最后结束这个条件判断的前一次已经执行过几次。**

### for循环

```
for(表达式 1; 表达式 2; 表达式 3){
 语句块
}
```

****

1. **先执行“表达式 1”。**
2. 判断表达式2的值真不真，真就执行{循环体}，为真才执行大花括号里面的语句，for和while一样，**如果刚开始条件判断就不满足，那么大花括号里面的语句一句都不执行**，for循环就结束了，但是你要说他没执行吧，它还是执行了一部分，表达式一就执行了，那么它执行的表达式一对后续有没有影响，稍后再讨论。
3. **表达式二的值为真，才执行花括号里面的东西！！！然后才是表达式三，对某个变量的值进行改变，或者其他，反正是花括号里的东西先执行完了，才能轮到表达式三**，然后就是再次的条件判断，为假，不执行，结束，为真，执行花括号，再执行表达式三。





**“表达式 1”仅在第一次循环时执行，以后都不会再执行，可以认为这是一个初始化语句。“表达式 2”一般是一
个关系表达式，决定了是否还要继续下次循环，称为“循环条件”。“表达式 3”很多情况下是一个带有自增或自
减操作的表达式，以使循环条件逐渐变得“不成立”**

无论是写成这样，

```
for(;i<101;){
    sum=sum+i;
    i=i+1;
    }
```

还是写成这样：

```
for(i=0;i<101;i++){
    sum=sum+i;
 
    }
```

**表达式二与表达式三都是条件判断成立之后才能执行，**

* **需要注意的一点是，当我们把表达式三的位置放在for（）这里面，花括号里的先执行，表达式三后执行，但是当我们把条件改变的这个表达式三放在花括号里面时，表达式三可能在原本花括号内的语句之前执行，例如**

  原本：

  ```
  for(i=0;i<101;i++){
      sum=sum+i;
      }
  ```

  

  表达式三 i++ 在   sum=sum+i之后执行

  后来：

  ```
  for(;i<101;){
  	i=i+1
      sum=sum+i;
      }
  ```

  **表达式三 i++ 在   sum=sum+i之前执行**

#### 注意的点！！！！

* 修改“从 1 加到 100 的和”的代码，要省略“表达式 1（初始化条件）的话，**可以看到，将 i=1 移到了 for 循环的外面**

  ```
  int i = 1 sum = 0;
  for (; i <= 100; i++) {
  	sum += i;
  }
  
  ```

* **省略了“表达式 2(循环条件)”，如果不做其它处理就会成为死循环**

  ```
  for (i = 1; ; i++) sum = sum + i;
  
  
  等价于：
  int i=1;
  do{
  sum=sum+1;
  i=i+1
  }while(1);
  
  还等价于：
  int i=1;
  while（1）{
  sum=sum+1；
  i=i+1；
  }
  ```

  **那么怎么做其他处理呢？这里需要后面讨论！！**

* **省略表达式三，而且也不在花括号里面对变量的值进行修改的话，意味着，对表达式二中的变量将无法进行修改，那么意味着，相当于是拿着表达式二中变量最开始的那个值，一次一次进行条件判断。想当然，如果变量最开始的值使得表达式二成立，那么就是相当于永远成立，while（1），如果，不成立，就不执行，结束。**

* 3 个表达式可以同时省略

  ```
  for（；；）
  
  等价于
  while（1）
  
  ```



* 表达式 1可以是初始化语句，也可以是其他语句

  ```
  for (sum = 0; i <= 100; i++) 
  sum = sum + i;
  
  printf("%d",sum)
  
  //这个可以输出结果的原因是sum=0，对sum进行了赋值，说明在前面就对sum进行了声明，声明了一个全局变量，才会使得在for循环外面打印是可以打出结果的！！！
  
  //如果是：
  for (int sum = 0; i <= 100; i++) 
  sum = sum + i;
  
  printf("%d",sum)
  
  
  //一定是错误的！！！
  //因为这里的sum是for循环里面的局部变量。
  //修改：
  for (int sum = 0; i <= 100; i++) {
  sum = sum + i;
  printf("%d",sum)
  }
  
  //把打印结果也放到里面时，哪怕是局部变量sum，我照样可以把你结果打出来,但是存在什么问题呢?就是“重复打印”！！！
  ```

  

* **“表达式 1”和“表达式 3”可以是一个简单表达式也可以是逗号表达式**

  

> # C语言逗号运算符
>
> 在C语言中逗号“,”也是一种运算符，称为逗号运算符。 其功能是把两个表达式连接起来组成一个表达式， 称为逗号表达式。其一般形式为：
>   **表达式1, 表达式2**
>
> **其求值过程是分别求两个表达式的值，并以表达式2的值作为整个逗号表达式的值**   **重要！！！！**
>
> 为什么说它重要，因为逗号运算符会和for一起考，
>
> 而且逗号运算符是 **顺序求值运算符**，连接多个表达式，从左往右 **对每个表达式进行求值**，把最后面的表达式的值作为整个表达式的值（表达式1，表达式2，表达式3，表达式4，表达式5），

* **注意在逗号表达式中，对里面的每个表达式都要求值！！！！！这意味着在逗号表达式中若对于某个值进行了修改，后续的程序也会受到影响，这是特别特别容易忽略的一个地方！！！！！**

```
#include <stdio.h>
int main(void){
    int a=2,b=4,c=6,x,y;
    y=(x=a+b),(b+c);
    printf("y=%d,x=%d",y,x);
    return 0;
}
```

```
运行结果：
y=10, x=6
```

惊不惊喜，意不意外，我的第一反应是：y=((x=a+b),(b+c))

然后y=10,这个是错误的！！！！确实，平时的时候我们遇到的运算符优先级都是高于赋值号的，所以惯性上，把赋值号放到最后一个看，今天傻眼了吧，哎，人家赋值号遇到逗号“  ，   ”，哟，要把逗号放到最后看）年少不知套路深，错把赋值号往后看！！！**赋值号遇到逗号，一定先看赋值号，把逗号放到后面看！！！**

* 赋值号遇到逗号，要想后看，必须把逗号放括号里面！！！！！！！



```
#include <stdio.h>
int main(void){
    int a=2,b=4,c=6,x,y;
    y=(x=a+b,b+c);
    printf("y=%d, x=%d \n",y,x);
    return 0;
}
```

```
运行结果：
y=10, x=6
```

* 逗号表达式一般形式中的表达式1和表达式2 也可以又是逗号表达式。例如：
    表达式1, ( 表达式2, 表达式3 )
* **程序中使用逗号表达式，通常是要分别求逗号表达式内各表达式的值，并不一定要求整个逗号表达式的值**

也就是说：在程序中我们常常用到逗号表达式是用来分别求逗号表达式中的各个表达式的值。

* 并不是在所有出现逗号的地方都组成逗号表达式，如在变量说明中，函数参数表中逗号只是用作各变量之间的间隔符。



#### 接着说for循环里的

* “表达式 1”和“表达式 3”可以是一个简单表达式也可以是逗号表达式。  

```
for (sum = 0 ，i = 1; i <= 100; i++)
sum = sum + i;
```

**这里的sum=0是对花括号里sum的初始化。**

2.



```
for (i = 0, j = 100; i <= 100; i++, j--)
k = i + j;
```

**i = 0, j = 100是对表达式3里面变量的初始化。**

一个小结：

* **在表达式1里用逗号表达式有两个情况：1.对花括号里的变量初始化。2.对表达式3里面的变量进行初始化。**

* **在表达式3里用逗号表达式是为了增添变化的变量，让两个变量同时变化！！！**

* **“表达式 2”一般是关系表达式或逻辑表达式，但也可是数值或字符，只要其值非零**

  ```
  for（i=0;ch=getchar()!='\n';i=i+ch）
  for（i=0;(ch=getchar())!='\n';i=i+ch）
  ```

  **这个例子绝了**!!! 

  **这个例子说明，表达式2不仅可以进行判断，他妈的还可以进行赋值，赋什么值，把判断的结果（真或假，0或1）赋值给一个变量，然后当你把这个变量的值累加起来时，你不就知道判断了多少次？？？判断的次数往往等价于一些我们要求的字符个数巴拉巴拉等等。**我还得到一个结论就是，当你把 **标志变量累加起来时，就得到了总个数，而标志变量，代表这进行某个步骤的次数，对标志变量累加，就得到这个步骤执行的总次数！！！！**

* 还有很小的一点是 **！= 的优先级高于=**

  

```
for (; (c = getchar()) != '\n'; )
```

### C 语言跳出循环（break 和 continue）

**当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语
句一起使用，即满足条件时便跳出循环**



使用break的本质：**提前结束循环（在不满足结束条件的情况下结束循环**

写代码问问自己：循环结束条件是啥？

如果我想在没有满足循环结束条件的情况下停止执行，那么我要用到if与break来结束**当前循环**。

**为什么是当前循环更准确，因为还存在多重循环**

7.17

K226 09:32~08:45 23个小时   武昌站~兰州站201

T306 19:08~14:48  20小时  武昌~兰州站189.5 *

Z138 20:26~15:03  18小时   武昌~兰州站201

Z126 16:39~12:08   19小时 武昌~兰州站198

7.18

K226 09:32~08:45 23小时  武昌~兰州 201* 

Z126 16:39~12:08 19小时  武昌~兰州 198*

T306 19:08~14:48 19小时 武昌~兰州 189.5

Z138 20:26~15:03 18小时  武昌~兰州 201*

Z230 22:54~16:29 17小时 武昌~兰州 189.5

* **while 循环很重要的一点是，它相当于for中的只进行条件判断，然后决定执不执行花括号里面的。如果我们把while循环的条件判断也取消呢，用if来进行条件判断，while（1），那么这个时候怎么办？**

* **答：所有的循环都是一样的，循环的初始条件是什么？变化的还是不变的？（如果是变化的往往要用到双层循环）循环的初始条件是一个还是多个？用while时，循环的初始条件都是要放在while（）{Todo}之前的**

  ```
  初始条件1；
  初始条件2；
  while（1）{
  
  TODO
  }
  ```

* **还要判断循环的结束，循环什么时候结束？如果要设置标志变量来记录执行次数，然后在根据次数来判断是否结束，那么你标志变量初始化还是得放在while（）前面。**

* 小结：**初始化的变量（也就是我说的表达式1）不能放在循环执行语句里面啊，那玩意相当于你每次条件判断后都要再初始化，如果你初始化的这个变量在循环执行的语句里要改变，你又给它初始化，那就引起了错误。**

* while与if搭配使用时

  ```
   while(1){
              
              sum=sum+j;
              printf("%-5d",sum);
              tag++;
              if (tag%4==0){
                  printf("\n");
                  break;
  
              }
              
              
              
  模型： while(1){
              
              TODO
              if (){
              	break；
      		}
  
              
              
  if这部分在Todo后面意味着
  先执行循环语句再执行条件判断
  相当于正常for循环里第二次的条件判断
  
  while(1){
              if (){
              	break；
      		}
              TODO
              
  
  
  if这部分在Todo前面意味着
  先执行条件判断再执行循环语句
  相当于正常for循环里第一次的条件判断
  条件不满足不执行下一次
  ```

  

### continue 语句

**continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环**

跳过某些剩余语句意味着：有些情况下，我就不执行几条循环语句，但是我并没有终止我的循环，我只是进入了下次循环

**continue 的本质，就是循环中我程序中出现一些异常情况时，我找到异常情况，满 足异常情况的情况我就用continue，跳过这次循环。进入到下次循环，防止我们在循环中计数或者执行一些步骤时，避免遇到异常情况，它还是能执行一些步骤。**

总结：！！！！！

**break 与 continue 的对比：break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，
直接跳到下一次循环，如果循环条件成立，还会继续循环**

##  C 语言循环嵌套

简单的 for 循环嵌套，外层循环和内层循环交叉执行，外层 for 每执行一次，内层 for 就要执行四次

1. ```
   #include <stdio.h>
   int main()
   for (i = 1; i <= 4; i++) { //外层for循环
   	for (j = 1; j <= 4; j++) { //内层for循环
   	printf("i=%d, j=%d\n", i, j);
   	}
   	printf("\n");
   	}
   	return 0;
    }
   	
   	
   	
   ```





**在 C 语言中，代码是顺序、同步执行的，当前代码必须执行完毕后才能执行后面的代码**

这就意味着，外层 for 每次循环时，都必须等待内层 for 循环完毕（也就是循环 4 次）才能进行下次循环，**如果代码没能得到我们需要的结果，可能是内层循环结束的条件出了问题，双重循环时，只有当内层循环结束才能进行外层的第二次循环**

外层初始化变量，判断条件是否成立，开始执行外层循环的内部，执行到内层循环，初始化变量的值，条件判断，执行内层循环里的代码，变量改变，继续往下执行，直到把外层循环的花括号里面都执行完毕，外层变量的改变。



```
#include <stdio.h>
	int main()
for (表达式1; 表达式2; 表达式3) { //外层

		TODO1

	
	for (表达式11; 表达式22; 表达式33) { //内层
		TODO2
	}
		
		
		TODO3
	
}
	return 0;
 }
```

执行顺序就是：

* **表达式1  **
* 表达式2
* TODO1
* 表达式11
* 表达式22
* TODO2
* 表达式33
* TODO3
* 表达式3

**需要思考的是：外层循环的TODO1部分我要写什么？也就是内层循环执行前我要写什么？然后内层循环的TODO2我要写什么？也就是内层循环里面我要写什么？再然后就是外层循环的TODO3部分我要写什么？也就是内层循环结束后我要干什么？**

**内层循环前要干嘛？内层循环后我要干嘛？**

**特别容易忽略的一点是：TODO3结束后，一定一定要执行外层循环的变量加加！！！！！**

> 内层里面的TODO2结束后一定一定要内层变量的加加！！！
>
> 然后执行TODO3结束后，一定一定要外层变量的加加！！！
>
> 还需要考虑的是：哪些变量是需要更新的，为什么内层循环每次都是1，2，3，4
>
> 答：**因为是双层循环，外层循环的存在导致内层循环的表达式1会循环初始化。外层循环多少次，内层循环的表达式1初始化多少次！！！！，而放在内层循环里面的初始化的代码，执行外面循环次数*内层循环次数次！！！！**而且内层循环的结束，不论是满足结束条件的结束，还是不满足结束条件的Break类型的结束都会导致开始执行TODO3，然后外层变量的加加，外层表达式2的判断，TODO1，表达式11，表达式22，TODO2，内层变量的加加，TODO3，外层变量的加加！！！！

* **对于 while 和 do-while 循环，循环体中应包括使循环趋于结束的语句。**
* **对于 while 和 do-while 循环，循环变量的初始化操作应该在 while 和 do-while 语句之前完成，而 for 循环可以在内部实现循环变量的初始化。**
* break 用来跳出所有循环，循环语句不再有执行的机会；
* continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。
* 此外，break 关键字还可以用于跳出 switch...case 语句。所谓“跳出”，是指一旦遇到 break，就不再执行 switch 
  中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个 switch 执行结束了，接着会执行整个 switch 后面的代码。











