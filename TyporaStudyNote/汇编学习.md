# 汇编学习

## 寄存器：

> CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012206.png)

> 寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。

## 寄存器的种类

早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。

- ```EAX
  EAX
  EBX
  ECX
  EDX
  EDI
  ESI
  EBP
  ESP
  ```

  ESP 寄存器有特定用途，保存当前 Stack (栈)的地址

## 内存模型：Heap

对于动态的内存占用请求（比如新建对象，或者使用`malloc`命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址`0x1000`开始给他分配，一直分配到地址`0x100A`，如果再要求得到22个字节，那么就分配到`0x1020`。

这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png)

> 系统分配的内存最大，有起始地址和结束地址，供整个程序来储存数据。
>
> 从分配好的这些内存中拿一些出来给用户（通常是用户要动态的占用内存`malloc`）这叫做堆Heap

## 内存模型：Stack

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png)

上面代码中，系统开始执行`main`函数时，会为它在内存里面建立一个帧（frame），所有`main`的内部变量（比如`a`和`b`）都保存在这个帧里面。`main`函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

如果函数内部调用了其他函数，会发生什么情况？

> ```clike
> int main() {
>    int a = 2;
>    int b = 3;
>    return add_a_and_b(a, b);
> }
> ```

上面代码中，`main`函数内部调用了`add_a_and_b`函数。执行到这一行的时候，系统也会为`add_a_and_b`新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：`main`和`add_a_and_b`。一般来说，调用栈有多少层，就有多少帧。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png)

等到`add_a_and_b`运行结束，它的帧就会被回收，系统会回到函数`main`刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是`0x8000`，第一帧假定是16字节，那么下一次分配的地址就会从`0x7FF0`开始；第二帧假定需要64字节，那么地址就会移动到`0x7FB0`。![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png)

## CPU指令

根据约定，程序从`_main`标签开始执行，这时会在 Stack 上为`main`建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。**后面如果有数据要写入`main`这个帧，就会写在 ESP 寄存器所保存的地址，（真正的意思：是它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器**）

> PUSH [寄存器] 
>
> 这时会将寄存器中的数据写入ESP指向的地址，并且ESP也会随之修改，将其指向下一个地址。
>
> POP [寄存器] 
>
> 这时会将ESP指向的地址上的数据写入寄存器，并且ESP也会随之修改，将其指向上一个地址。
>
> ESP 也是一个寄存器（stack pointer），也就是栈指针。

**执行流程：从main标签开始执行，先为main创建一个stack（栈），然后写入数据时，也就是将3写入这个栈，首先，我先取出地址减去四个字节，把新地址写入寄存器，得到新地址写入这个新地址的开始的四个字节**

`mov`指令用于将一个值写入某个寄存器。

> ```clike
> mov    %eax, [%esp+8] 
> ```



`add`指令用于将两个运算子相加，并将结果写入第一个运算子。

> ```clike
> add    %eax, %ebx
> ```



`pop`指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。

> ```clike
> pop    %ebx
> ```

`ret`指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。

> ```clike
> ret
> ```





