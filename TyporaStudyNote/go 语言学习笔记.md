# go 语言学习笔记

### 并发模型

**可以说，Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然。**

搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。

可以说，内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。**使用 cache 为当前执行线程提供无锁分配，** **多个 central 在不同线程间平衡内存单元复用**。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。

# Go语言依赖管理

## go module

go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。

在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。

- GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。

- GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。

- GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。

  

```
MacOS 或者 Linux 下开启 GO111MODULE 的命令为：

export GO111MODULE=on 或者 export GO111MODULE=auto
```

| 命令            | 作用                                           |
| --------------- | ---------------------------------------------- |
| go mod download | 下载依赖包到本地（默认为 GOPATH/pkg/mod 目录） |
| go mod edit     | 编辑 go.mod 文件                               |
| go mod graph    | 打印模块依赖图                                 |
| go mod init     | 初始化当前文件夹，创建 go.mod 文件             |
| go mod tidy     | 增加缺少的包，删除无用的包                     |
| go mod vendor   | 将依赖复制到 vendor 目录下                     |
| go mod verify   | 校验依赖                                       |
| go mod why      | **解释为什么需要依赖**                         |

#### GOPROXY

proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过`go get `命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。

目前公开的代理服务器的地址有：

- goproxy.io
- goproxy.cn：（推荐）由国内的七牛云提供。

```

Windows 下设置 GOPROXY 的命令为：

go env -w GOPROXY=https://goproxy.cn,direct

MacOS 或 Linux 下设置 GOPROXY 的命令为：

export GOPROXY=https://goproxy.cn
```

Go语言在 1.13 版本之后 GOPROXY 默认值为 https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将 GOPROXY 设置为国内的 goproxy.cn。

#### 使用go get命令下载指定版本的依赖包

执行`go get `命令，在下载依赖包的同时还可以指定依赖包的版本。

- 运行`go get -u`命令会将项目中的包升级到最新的次要版本或者修订版本；
- 运行`go get -u=patch`命令会将项目中的包升级到最新的修订版本；
- 运行`go get [包名]@[版本号]`命令会下载对应包的指定版本或者将对应包升级到指定的版本。

# start go

* ## **import（导入包）**

  在包声明之后，是 import 语句，用于导入程序中所依赖的包，导入的包名使用双引号`""`包围.

  导入的包中不能含有代码中没有使用到的包，否则Go编译器会报编译错误

  也可以使用一个 import 关键字导入多个包，此时需要用括号`( )`将包的名字包围起来，并且每个包名占用一行

* ## main 函数

  main 函数只能声明在 main 包中，不能声明在其他包中，并且，一个 main 包中也必须有且仅有一个 main 函数

main 函数是自定义函数的一种，在Go语言中，所有函数都以关键字 func 开头的，定义格式如下所示：

```
func 函数名 (参数列表) (返回值列表){
  函数体
}
```

**参数列表：一个参数由参数变量和参数类型组成，例如`func foo( a int, b string )`**

**返回值列表**：可以是返回值类型列表，也可以是变量名与类型的组合列表

**函数有返回值时必须要在函数体中以return语句返回 ** main函数一般没有返回值

**Go语言函数的左大括号`{`必须和函数名称在同一行，否则会报错**

* ## **go build 命令**

#### 1) 当参数不为空时

如果 fileName 为同一 main 包下的所有源文件名（可能有一个或者多个），编译器将生成一个与第一个 fileName 同名的可执行文件（如执行`go build abc.go def.go ...`会生成一个 abc.exe 文件）；如果 fileName 为非 main 包下的源文件名，编译器将只对该包进行语法检查，不生成可执行文件。

#### 2) 当参数为空时

如果当前目录下存在 main 包，则会生成一个与当前目录名同名的“目录名.exe”可执行文件（如在 hello 目录中执行`go build`命令时，会生成 hello.exe 文件）；如果不存在 main 包，则只对当前目录下的程序源码进行语法检查，不会生成可执行文件。

* ## Go语言变量的声明（使用var关键字）

  

```
标准格式
var temp string

var ptemp1,ptemp2 *int

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的
```

基本的数据类型有：

* bool 
* string 
* int  int8  int16  int 32 int 64
* uint8   uint 16   uint  32  uint 64 

byte = uint 8

rune = int 32 

* float32    float 64

#### 批量格式

```
var  （
	a int 
	b string
	c bool
	d byte
	e rune
	f *int
	arr[] int 
	g struct{
		x int 
		y bool
	}
）
```

#### 简短格式

a :=  3+4

限制：

- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。

i ，j := 0 ,1

**var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方**

## 变量初始化的标准格式

```
var temp int =10
```

#### 编译器推导类型的格式

```
var temp =100
等价于
var temp int =100

var attack = 40
等价于
var attack int =100

var damageRate =0.17
等价于
var damageRate float64  =100

var damage = float32(attack-defence) * damageRate
等价于
var damage float32  =100

由于Go语言和C语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 damageRate 变量的类型，Go语言编译器会将 damageRate 类型推导为 float64，我们这里不需要 float64 的精度，所以需要强制指定类型为 float32。
```

#### 短变量声明并初始化

hp := 100

注意：由于使用了`:=`，而不是赋值的`=`，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误

`:=`是声明并初始化赋值

短变量声明的形式在开发中的例子较多：

```
conn, err := net.Dial("tcp","127.0.0.1:8080")
```

net.Dial 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象（conn），一个是错误对象（err）。如果是标准格式将会变成

```
var conn net.Conn
var err error
conn, err = net.Dial("tcp", "127.0.0.1:8080")
```

**因此，短变量声明并初始化的格式在开发中使用比较普遍**

注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下

> 单个短变量声明和赋值，要求这个变量之前没有被声明过
>
> 对个短变量的声明和赋值，要求至少有一个之前没有被声明过
>
> 如下所示：

```
 conn, err := net.Dial("tcp", "127.0.0.1:8080")
 conn2, err := net.Dial("tcp", "127.0.0.1:8080")
```

**上面的代码片段，编译器不会报 err 重复定义。**

# Go语言多个变量同时赋值

**go 语言多个变量赋值的本质是：把要被赋值的变量的值都储存在临时变量中，拿临时变量去赋值**



# Go语言匿名变量（没有名字的变量）

匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。

# Go语言变量的作用域

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。

了解变量的作用域对我们学习Go语言来说是比较重要的，因为Go语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误

根据变量定义位置的不同，可以分为以下三个类型：

- 函数内定义的变量称为局部变量
- 函数外定义的变量称为全局变量
- 函数定义中的变量称为形式参数

## 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量

```
package main
import (
    "fmt"
)
func main() {
    //声明局部变量 a 和 b 并赋值
    var a int = 3
    var b int = 4
    //声明局部变量 c 并计算 a 和 b 的和
    c := a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```



## 全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

```
package main
import "fmt"
//声明全局变量
var c int
func main() {
    //声明局部变量
    var a, b int
    //初始化参数
    a = 3
    b = 4
    c = a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```



Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。

```
package main
import "fmt"
//声明全局变量
var a float32 = 3.14
func main() {
    //声明局部变量
    var a int = 3
    fmt.Printf("a = %d\n", a)
}

```

## 形式参数

在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。

# Go语言整型（整数类型）

Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 int8、int16、int32、int64 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。

Go语言同时提供了有符号和无符号的整数类型，其中包括 int8、int16、int32 和 int64 四种大小截然不同的有符号整数类型，分别对应 8、16、32、64 bit（二进制位）大小的有符号整数，与此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整数类型。

此外还有两种整数类型 int 和 uint，它们分别对应特定 CPU 平台的字长（机器字大小），其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。

**大多数情况下，我们只需要 int 一种整型即可，它可以用于循环计数器（for 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 int 类型的处理速度也是最快的。**

**用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样，byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数**

**最后，还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。**

**尽管在某些特定的运行环境下 int、uint 和 uintptr 的大小可能相等，但是它们依然是不同的类型，比如 int 和 int32，虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。**

## 哪些情况下使用 int 和 uint

程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用 int 来表示。

反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint。



# Go语言浮点类型（小数类型）



这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：

- 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
- 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
- float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。


一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。



浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：

```
const e = .71828 // 0.71828
const f = 1.     // 1


很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：
```

```

const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
```



# Go语言复数

在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。

Go语言中复数的类型有两种，分别是 complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。

**复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。**

声明复数的语法格式如下所示：

```
var name complex128 = complex(x, y)
```

其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。

**对于一个复数`z := complex(x, y)`，可以通过Go语言的内置函数`real(z) `来获得该复数的实部，也就是 x；通过`imag(z) `获得该复数的虚部，也就是 y。**

Go语言内置的 math/cmplx 包中提供了很多操作复数的公共方法，实际操作中建议使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数。





# Go语言输出正弦函数（Sin）图像



在Go语言中，正弦函数由 math 包提供，函数入口为 math.Sin，正弦函数的参数为 float64，返回值也是 float64。在使用正弦函数时，根据实际精度可以进行转换。

Go语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 JPEG、PNG、GIF 等。





# Go语言bool类型（布尔类型）

**Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。**



布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：

```
i := 0
if b {
    i = 1
}

```

如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示

```
// 如果b为真，btoi返回1；如果为假，btoi返回0
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数

```
// itob报告是否为非零。
func itob(i int) bool { return i != 0 }
```



Go语言中不允许将整型强制转换为布尔型，所以我们使用函数封装来转化

# Go语言字符串

字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）

**字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。**

**字符串一旦定义就无法修改**



## 定义字符串

可以使用双引号`""`来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：

- \n：换行符

- \r：回车符

- \t：tab 键

- \u 或 \U：Unicode 字符

- \\：反斜杠自身

  

**字符串的比较**



> 字符串的比较本质是在内存中按照字节进行比较，从而实现字符串的比较

**字符串内容的获得**

字符串的内容（纯字节）可以通过标准索引法来获取，在方括号`[ ]`内写入索引，索引从 0 开始计数：

- 字符串 str 的第 1 个字节：str[0]
- 第 i 个字节：str[i - 1]
- 最后 1 个字节：str[len(str)-1]
- 需要强调的是这种只针对纯ASCII有用

**在go语言中获取某个字节的地址属于非法行为**，例如 &str[i]。

**字符串的拼接**：

两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。

**提示：因为编译器会在行尾自动补全分号，所以拼接字符串过于长时用的加号“+”必须放在第一行末尾。**

```
//正确写法
str := "Beginning of the string " +
"second part of the string"
//错误写法
str := "Beginning of the string " 
+"second part of the string"

//正确写法对字符串进行拼接
s := "hel" + "lo,"
s += "world!"
fmt.Println(s) //输出 “hello, world!”
```

## 字符串实现基于 UTF-8 编码

所以**通过 rune 类型，可以方便地对每个 UTF-8 字符进行访问。当然，Go语言也支持按照传统的 ASCII 码方式逐字符进行访问**。



## 定义多行字符串

在Go语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量（string literal），这种双引号字面量不能跨行

**在go语言中双引号不能跨行**

**若要实现跨行则：**

就必须使用

```
``反引号
```

```
const str = `第一行
第二行
第三行
\r\n
`
fmt.Println(str)
```

代码运行结果：

第一行
第二行
第三行
\r\n



反引号``，，两个反引号间的字符串将被原样赋值到 str 变量中。

在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。**反引号给字符串赋值，反引号间的换行被视为字符串间的换号，任何转义字符都无用，这些转义字符将会原样输出**



**在`间的所有代码均不会被编译器识别，而只是作为字符串的一部分**



# Go语言计算字符串长度——len()和RuneCountInString()

* Go 语言的内建函数 len()，可以用来获取切片、字符串、通道（channel）等的长度

```
tip1 := "genji is a ninja"
fmt.Println(len(tip1))
tip2 := "忍者"
fmt.Println(len(tip2))
```

程序输出如下：
16
6

**字符串的长度，对于含有空格的纯asscii来说，空格和字符的个数就是字符串的长度，但是对于，汉字来说，字符串的长度不一定是汉字的个数**

**len() 函数的返回值的类型为 int，表示字符串的 ASCII 字符个数或字节长度。**



**这里的差异是由于 Go 语言的字符串都以 UTF-8 格式保存，每个中文占用 3 个字节，因此使用 len() 获得两个中文文字对应的 6 个字节。**

> 在go语言中，每个中文字符占三个字节，因为go中的字符串都是以UTF-8的格式保存



**如果希望按习惯上的字符个数来计算，就需要使用 Go 语言中 UTF-8 包提供的 RuneCountInString() 函数，统计 Uncode 字符数量。**

**下面的代码展示如何计算UTF-8的字符个数。**

```
fmt.Println(utf8.RuneCountInString("忍者"))fmt.Println(utf8.RuneCountInString("龙忍出鞘,fight!"))
```

程序输出如下：
2
11


ASCII 字符串长度使用 len() 函数。

Unicode 字符串长度使用 utf8.RuneCountInString() 函数。



# Go语言遍历字符串——获取每一个字符串元素



## 遍历每一个ASCII字符

```
theme := "狙击 start"
for i := 0; i < len(theme); i++ {
    fmt.Printf("ascii: %c  %d\n", theme[i], theme[i])
}

输出：
ascii: ?  231
ascii:     139
ascii:     153
ascii: ?  229
ascii:     135
ascii: ?  187
ascii:    32
ascii: s  115
ascii: t  116
ascii: a  97
ascii: r  114
ascii: t  116
```



## 按Unicode字符遍历字符串



```
theme := "狙击 start"
for _, s := range theme {
    fmt.Printf("Unicode: %c  %d\n", s, s)
}


输出：
Unicode: 狙  29401
Unicode: 击  20987
Unicode:    32
Unicode: s  115
Unicode: t  116
Unicode: a  97
Unicode: r  114
Unicode: t  116
```



- ASCII 字符串遍历直接使用下标。
- Unicode 字符串遍历用 for range。



# Go语言字符串截取（获取字符串的某一段字符）

```
tracer := "死神来了, 死神bye bye"
comma := strings.Index(tracer, ", ")
pos := strings.Index(tracer[comma:], "死神")
fmt.Println(comma, pos, tracer[comma+pos:])


输出：
12 3 死神bye bye
```

代码说明如下：
1) 第 2 行尝试在 tracer 的字符串中搜索中文的逗号，返回的位置存在 comma 变量中，类型是 int，表示从 tracer 字符串开始的 ASCII 码位置。

strings.Index() 函数并没有像其他语言一样，提供一个从某偏移开始搜索的功能。不过我们可以对字符串进行切片操作来实现这个逻辑。

2）第4行中，tracer[comma:] 从 tracer 的 comma 位置开始到 tracer 字符串的结尾构造一个子字符串，返回给 string.Index() 进行再索引。得到的 pos 是相对于 tracer[comma:] 的结果。

comma 逗号的位置是 12，而 pos 是相对位置，值为 3。我们为了获得第二个“死神”的位置，也就是逗号后面的字符串，就必须让 comma 加上 pos 的相对偏移，计算出 15 的偏移，然后再通过切片 tracer[comma+pos:] 计算出最终的子串，获得最终的结果：“死神bye bye”。



#### 总结

字符串索引比较常用的有如下几种方法：

- strings.Index：正向搜索子字符串。
- strings.LastIndex：反向搜索子字符串。
- 搜索的起始位置可以通过切片偏移制作。







# Go语言修改字符串

****





# go语言高级编程



## 数组、字符串和切片三者的关系

这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。

**首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的**

**Go语言字符串底层数据也是对应的字节数组**，只是因为字符串的只读属性禁止了在程序中对底层字节数组的元素的修改，所以字符串不可以修改，数组可以修改。

* 字符串和数组的底层数据都是一样的，字符串的底层数据是字节数组，但是字符串只读，数组可以读，可以修改
* 字符串的赋值，本质是赋值字符串所在的数据的地址，和对应的长度。不是底层数据的复制。
* 切片的底层数据是对应数据类型的数组，解除了只读的限制。除了是对应数据类型的数组，还有独立的长度和容量信息。切片的赋值和往函数里传参数，都是把切片的头部信息按传值方式处理。因为切片的头含有底层数据结构的指针，所以切片的赋值和函数传参都是以传值的方式处理。也就是地址的复制。

##  数组



在go语言中，数组的长度是数组类型的组成部分，**不同的长度或者是不同的类型的组成数据都是不同的数组。**

Go语言中很少直接使用数组的原因是：（不同长度的数组，因为数组类型不同而导致无法直接赋值）

**而更加灵活的便是切片：，切片是可以动态增长和收缩的序列**

数组的定义方式：



```
var a [3]int                    // 定义长度为3的int型数组, 元素全部为0
var b = [...]int{1, 2, 3}       // 定义长度为3的int型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
```



* 第一种方式是定义一个数组变量的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化。
* 第二种方式定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的数目自动计算。
* 第三种方式是以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。这种初始化方式和`map[int]Type`类型的初始化语法类似。数组的长度以出现的最大的索引为准，没有明确初始化的元素依然用0值初始化。
* 第四种方式是混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三第四个元素零值初始化，第五个元素通过索引初始化，最后一个元素跟在前面的第五个元素之后采用顺序初始化。

数组的内存结构比较简单。比如下面是一个`[4]int{2,3,5,7}`数组值对应的内存结构：

![image-20210721172734926](/home/gongna/snap/typora/39/.config/Typora/typora-user-images/image-20210721172734926.png)

> go 语言中数组是值语义，也就是数组变量就是整个数组。不是隐式的指向第一个元素的指针。而是一个完整的值。当数组被赋值或者传递时，会复制整个数组，当数组比较大时，数组的赋值就会有很大的开销。一般采用传递一个指向数组的指针。

```
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针

fmt.Println(a[0], a[1])   // 打印数组的前2个元素
fmt.Println(b[0], b[1])   // 通过数组指针访问数组元素的方式和数组类似

for i, v := range b {     // 通过数组指针迭代数组的元素
    fmt.Println(i, v)
}
```

其中`b`是指向`a`数组的指针，但是通过`b`访问数组中元素的写法和`a`类似的。还可以通过`for range`来迭代数组指针指向的数组元素。其实数组指针类型除了类型和数组不同之外，通过数组指针操作数组的方式和通过数组本身的操作类似，而且数组指针赋值时只会拷贝一个指针。

> 通过数组指针访问数组元素，操作数组元素的方式与数组本身类似。

但是！！！

数组指针类型仍然不够灵活，需要强调的是，数组的长度是数组类型的一部分，指向不同长度的数组的指针仍然是不同的指针，指针类型不同。

还可以将数组看做是特殊的结构体，结构体的字段名对应数组的索引，结构的成员数目是固定的，内置的`len` 可以计算数组的长度，内置的`cap`可以计算数组的容量。但二者计算出的数组的长度都是一样的。





#### 数组的遍历

```
for i := range a {
        fmt.Printf("a[%d]: %d\n", i, a[i])
    }
    for i, v := range b {
        fmt.Printf("b[%d]: %d\n", i, v)
    }
    for i := 0; i < len(c); i++ {
        fmt.Printf("c[%d]: %d\n", i, c[i])
    }
```

```
 var times [5][0]int
    for range times {
        fmt.Println("hello")
    }
    
    
    //用for range方式迭代，还可以忽略迭代时的下标
```

数组不仅仅可以用于数值类型，还可以定义字符串数组、结构体数组、函数数组、接口数组、管道数组等等：

```

// 字符串数组
var s1 = [2]string{"hello", "world"}
var s2 = [...]string{"你好", "世界"}
var s3 = [...]string{1: "世界", 0: "你好", }
//空的字符串数组
var s4 = [...]string {}



// 结构体数组
var line1 [2]image.Point
var line2 = [...]image.Point{image.Point{X: 0, Y: 0}, image.Point{X: 1, Y: 1}}
var line3 = [...]image.Point{{0, 0}, {1, 1}}

//空的结构体数组
var lines4 = [...] image.Point{

}//这里的image.Point 是已经被定义好的结构体类型

var lines5 = [...] struct {} {

}


// 图像解码器数组
var decoder1 [2]func(io.Reader) (image.Image, error)
var decoder2 = [...]func(io.Reader) (image.Image, error){
    png.Decode,
    jpeg.Decode,
}
//空的函数数组
var decoder3 = [...]func()(){

}

// 接口数组
var unknown1 [2]interface{}
var unknown2 = [...]interface{}{123, "你好"}

//空的接口数组
var unknown3 = [...]interface{}{

}


// 管道数组
var chanList = [2]chan int{}
//空的管道数组
var chanList = [...] chan int {


}
```



## 字符串

一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，**字符串的元素不可修改，是一个只读的字节数组**。

每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分

在go语言中，字符串的长度虽然是固定的，但是字符串的长度不是字符串类型的一部分。字符串的字节长度才是字符串的一部分。

* **字符串结构由两个信息组成：第一个是字符串指向的底层字节数组**
* <u>*第二个是字符串的字节的长度*</u>

**字符串其实是一个结构体，因此字符串的赋值操作也就是`reflect.StringHeader`结构体的复制过程**，并不会涉及底层字节数组的复制。



![image-20210721194356217](/home/gongna/snap/typora/39/.config/Typora/typora-user-images/image-20210721194356217.png)

“Hello, world”字符串底层数据和以下数组是完全一致的：

```
var data = [...] byte {'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd',} 
```



**字符串虽然不是切片，但是支持切片操作**

```
s := "hello, world"
hello := s[:5]
world := s[7:]

s1 := "hello, world"[:5]
s2 := "hello, world"[7:]
```

字符串和数组类似，内置的`len`函数返回字符串的长度。也可以通过`reflect.StringHeader`结构访问字符串的长度（这里只是为了演示字符串的结构，并不是推荐的做法）：

```
fmt.Println("len(s):", (*reflect.StringHeader)(unsafe.Pointer(&s)).Len)   // 12
fmt.Println("len(s1):", (*reflect.StringHeader)(unsafe.Pointer(&s1)).Len) // 5
fmt.Println("len(s2):", (*reflect.StringHeader)(unsafe.Pointer(&s2)).Len) // 5
```



**提到Go字符串时，我们一般都会假设字符串对应的是一个合法的UTF8编码的字符序列。可以用内置的`print`调试函数或`fmt.Print`函数直接打印，也可以用`for range`循环直接遍历UTF8解码后的Unicode码点值。**

下面的“Hello, 世界”字符串中包含了中文字符，可以通过打印转型为字节类型来查看字符底层对应的数据

```
fmt.Printf("%#v\n", []byte("Hello, 世界"))

输出
[]byte{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0xe4, 0xb8, 0x96, 0xe7, \
0x95, 0x8c}
```

*图 1-9 字符串布局*

![image-20210721195151665](/home/gongna/snap/typora/39/.config/Typora/typora-user-images/image-20210721195151665.png)



Go语言的字符串中可以存放任意的二进制字节序列，而且即使是UTF8字符序列也可能会遇到坏的编码。如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘�’。

下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为“�”，第二和第三字节则被忽略，后面的“abc”依然可以正常解码打印（错误编码不会向后扩散是UTF8编码的优秀特性之一）。

```
fmt.Println("\xe4\x00\x00\xe7\x95\x8cabc") // �界abc

```

**如果不想解码UTF8字符串，想直接遍历原始的字节码，可以将字符串强制转为`[]byte`字节序列后再行遍历（这里的转换一般不会产生运行时开销）：**

```
for i, c := range []byte("世界abc") {
    fmt.Println(i, c)
}
```

或者是采用传统的下标方式遍历字符串的字节数组



```
const s = "\xe4\x00\x00\xe7\x95\x8cabc"
for i := 0; i < len(s); i++ {
    fmt.Printf("%d %x\n", i, s[i])
}
```

**Go语言除了`for range`语法对UTF8字符串提供了特殊支持外，还对字符串和`[]rune`类型的相互转换提供了特殊的支持。**

> 字符串相关的强制类型转换主要涉及到`[]byte`和`[]rune`两种类型。每个转换都可能隐含重新分配内存的代价，最坏的情况下它们的运算时间复杂度都是`O(n)`。不过字符串和`[]rune`的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的`[]byte`和`[]int32`类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。



`for range`迭代字符串：

> 每次解码一个Unicode字符，然后进入`for`循环体，遇到崩坏的编码并不会导致迭代停止。

```
for range对字符串的迭代模拟实现

func forOnString(s string, forBody func(i int, r rune)) {
    for i := 0; len(s) > 0; {
        r, size := utf8.DecodeRuneInString(s)
        forBody(i, r)
        s = s[size:]
        i += size
    }
}
```



```
[]byte(s)转换模拟实现

func str2bytes(s string) []byte {
    p := make([]byte, len(s))
    for i := 0; i < len(s); i++ {
        c := s[i]
        p[i] = c
    }
    return p
}

```



```
string(bytes)转换模拟实现

func bytes2str(s []byte) (p string) {
    data := make([]byte, len(s))
    for i, c := range s {
        data[i] = c
    }

    hdr := (*reflect.StringHeader)(unsafe.Pointer(&p))
    hdr.Data = uintptr(unsafe.Pointer(&data[0]))
    hdr.Len = len(s)

    return p
}

```

**因为Go语言的字符串是只读的，无法直接同构构造底层字节数组生成字符串。在模拟实现中通过`unsafe`包获取了字符串的底层数据结构，然后将切片的数据逐一复制到了字符串中，这同样是为了保证字符串只读的语义不会受切片的影响。如果转换后的字符串在生命周期中原始的`[]byte`的变量并不会发生变化，编译器可能会直接基于`[]byte`底层的数据构建字符串**





```
[]rune(s)转换模拟实现

func str2runes(s string) []rune{
    var p []int32
    for len(s)>0 {
        r,size:=utf8.DecodeRuneInString(s)
        p=append(p,int32(r))
        s=s[size:]
        }
        return []rune(p)
}

因为底层内存结构的差异，字符串到[]rune的转换必然会导致重新分配[]rune内存空间，然后依次解码并复制对应的Unicode码点值。这种强制转换并不存在前面提到的字符串和字节切片转化时的优化情况。
```





```
string(runes)转换模拟实现

func runes2string(s []int32) string {
    var p []byte
    buf := make([]byte, 3)
    for _, r := range s {
        n := utf8.EncodeRune(buf, r)
        p = append(p, buf[:n]...)
    }
    return string(p)
}
同样因为底层内存结构的差异，[]rune到字符串的转换也必然会导致重新构造字符串。这种强制转换并不存在前面提到的优化情况。
```



## 切片(slice)

简单地说，切片就是一种简化版的动态数组。因为动态数组的长度是不固定，切片的长度自然也就不能是类型的组成部分了。数组虽然有适用它们的地方，但是数组的类型和操作都不够灵活，因此在Go代码中数组使用的并不多。而切片则使用得相当广泛，理解切片的原理和用法是一个Go程序员的必备技能。

```
切片的结构定义reflect.SliceHeader

type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}


切片的开头部分和Go字符串是一样的，但是切片多了一个Cap成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。
```

`x := []int{2,3,5,7,11}`和`y := x[1:3]`两个切片对应的内存结构：



![img](https://chai2010.gitbooks.io/advanced-go-programming-book/content/images/ch1-10-slice-1.ditaa.png)



> 切片的len 与切片的cap可能一样也可能不一样

让我们看看切片有哪些定义方式：

```

var (
   a [] int          	// nil切片, 和 nil 相等, 一般用来表示一个不存在的切片
   b = [] int {}     	// 空切片, 和 nil 不相等, 一般用来表示一个空的集合
   c = [] int{1,2,3}	// 有3个元素的切片, len和cap都为3
   d = c[0:2]      		// 有2个元素的切片, len为2, cap为3
   e = c[0:2:cap(c)]	// 有2个元素的切片, len为2, cap为3
   f = c[:0]    		// 有0个元素的切片, len为0, cap为3
   g = make([]int ,3)	// 有3个元素的切片, len和cap都为3
   h = make([]int ,2,3) // 有2个元素的切片, len为2, cap为3
   i = make([]int ,0,3)	// 有0个元素的切片, len为0, cap为3
)
```



* 和数组一样，内置的`len`函数返回切片中有效元素的长度，内置的`cap`函数返回切片容量大小，容量必须大于或等于切片的长度。也可以通过`reflect.SliceHeader`结构访问切片的信息（只是为了说明切片的结构，并不是推荐的做法
* 切片可以和`nil`进行比较，**只有当切片底层数据指针为空时切片本身为`nil`**

- 这时候切片的长度和容量信息将是无效的。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了



```
 遍历切片的方式和遍历数组的方式类似
 for i:= range a{
 	fmt.Println("a[%d]:%d",i,a[i])
 }
 
 for k,v := range a{
 	fmt.Println("a[%d]:%d",k,v)
 
 }
 
 for i:=0;i<len(a);i++{
 	fmt.Println("a[%d]:%d",i,a[i])
 
 }
 其实除了遍历之外，只要是切片的底层数据指针、长度和容量没有发生变化的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader)
```

> 复制片头信息（reflect.SliceHeader)个人的理解是，复制结构体的地址，相当于一个指针指向切片。

> 个人觉得值得注意的主要有以下三点：
>
> * 数组变量是数组本身，拿数组去赋值，要对数组数据进行复制，这也是传数组给函数做参数时开销大的原因，所以我们一般采取，取数组的地址，拿数组指针去对数组进行操作。
> * 切片不同的是，拿切片去赋值（更准确的说是对切片本身赋值或者参数传递），相当于是拿一个指向切片的指针，在这种程度上来说，切片更加相似与数组指针，而不是数组！！！(因为只是复制切片头信息（`reflect.SliceHeader`），并不会复制底层的数据)
> * 还有一点是：**切片的类型与长度无关**，这一点和数组截然不同。只要是相同元素构成的切片，他们的类型就是相同的。

**添加切片元素**

* 在切片的尾部添加元素

```
//内置的泛型函数append可以在切片的尾部追加N个元素：

var a []int  //相当于nil的切片 
a=append(a,1)	 // 追加1个元素
a=append(a,1,2,3)   // 追加多个元素, 手写解包方式
a=append(a,[]int{1,2,3}...)	// 追加一个切片, 切片需要解包

```

不过要注意的是，在容量不足的情况下，`append`的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用`append`函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。

* 除了在切片的尾部追加，我们还可以在切片的开头添加元素

```
var a = []int{1,2,3}
a=append([]int{0},a...)		// 在开头添加1个元素

a=append([]int{1,2,3},a...)  	// 在开头添加1个切片

```

- 由于`append`函数返回新的切片，也就是它支持链式操作。我们可以将多个`append`操作组合起来，实现在切片中间插入元素

#### 用append实现在切片的某个位置插入一个元素或者插入多个元素

```
var a [] int


a = append(a[:i],append([]int {x},a[i:]...)...)//在第i个位置插入x

a = append（a[:i],append([] int {1,2,3},a[i:]...)...）//在i个位置插入切片
```



> 每个添加操作中的第二个`append`调用都会创建一个临时切片，并将`a[i:]`的内容复制到新创建的切片中，然后将临时创建的切片再追加到`a[:i]`。
>
> 简单的说就是：append([]int{x}, a[i:]...)...新建切片[ ]int {x}，然后把a[i:].的值复制到新建的切片，然后把新建的切片追加到x的后面。

#### 用copy实现在切片的某个位置插入一个元素

可以用`copy`和`append`组合可以避免创建中间的临时切片，同样是完成添加元素的操作：

```
1.  a=append(a,0)  //切片拓展一个空间  -->这一步很重要，扩大了切片的容量，不然，你                    //把a[i:]向后移动1个位置会造成数据的缺失

2.  copy(a[i+1:],a[i:]) // a[i:]向后移动1个位置，会把我们新追加的0给舍弃

3.  a[i]=x   			// 设置新添加的元素





值得注意的是，copy函数实现的只是数据的复制，
我们知道切片的赋值啥的，其实是传切片底层的片头信息（reflect.SliceHeader)
传地址，不会发生底层数据的复制，所以以下两个例子产生的效果是完全不同的

// 引用切片数据
    refData := srcData
    
// 预分配足够多的元素切片
    copyData := make([]int, elementCount)
// 将数据复制到新的切片空间中
    copy(copyData, srcData)
    
// 修改原始数据的第一个元素
    srcData[0] = 999
    
// 打印引用切片的第一个元素
    fmt.Println(refData[0]) 
// 打印复制切片的第一个元素
	fmt.Println(copyData[0])  
	
	
//结果是：copyData[0]数据未发生改变，仍然是srcData的原始数据
		refData[0]数据发生改变
	

```



- 第一句`append`用于扩展切片的长度，为要插入的元素留出空间
- 第二句`copy`操作将要插入位置开始之后的元素向后挪动一个位置
- 第三句真实地将新添加的元素赋值到对应的位置
- 操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片

#### 用append和copy的梦幻联动实现在切片的某个位置插入多个元素



```
1.明确你要插入元素的个数，用循环来实现多次扩展从而实现为切片扩展足够的空间

a = append(a, x...)       // 为x切片扩展足够的空间

2. 将a[i:]向后移动多次，同样可以通过循环来实现

copy (a[i+1:],a[i:])
copy(a[i+2:],a[i+1:])
copy(a[i+3:],a[i+2:])....

3.复制新添加的切片,相当于是填补空缺，空缺的个数和要添加的切片的元素个数一定是相等的，否则就会 出现元素的缺失

copy(a[i:],x)
```

**稍显不足的是，在第一句扩展切片容量的时候，扩展空间部分的元素复制是没有必要的。没有专门的内置函数用于扩展切片的容量**

> 在go中没有专门的函数用来扩展切片的容量，用append来扩展切片容量时，不可避免的会进行扩展空间部分元素的复制
>
> `append`本质是用于追加元素而不是扩展容量，扩展切片容量只是`append`的一个副作用



#### 删除切片的元素

删除元素的位置有三种情况：从开头位置删除，从中间位置删除，从尾部删除。其中删除切片尾部的元素最快

```

1.从尾部删除切片的元素

a = []int{1, 2, 3}

a = a[:len(a)-1] // 删除尾部1个元素

a = a[:len(a)-n] // 删除尾部N个元素

2.从开头删除切片的元素

   1)通过移动数据指针

a = []int{1, 2, 3}

a = a[1:]       // 删除开头1个元素

a = a[n:]		// 删除开头N个元素

   2)不通过移动数据指针，而是将后面的数据向前移动(用append实现)

a = []int{1, 2, 3}

a = append(a[:0],a[1:]...)		// 删除开头1个元素

a = append(a[:0],a[n:]...)		// 删除开头N个元素

	3)不通过移动数据指针，而是将后面的数据向前移动(用copy实现)

 copy( destSlice, srcSlice []T) int  
 copy() 函数的返回值表示实际发生复制的元素个数。所以


  第一步：copy(a,a[1:])，此时a已经发生变化，但是a的容量没有发生变化，末尾会多出来一个数据
  第二步：改变a的容量,主要是取决于copy返回的是发生复制的元素的个数
  a = a[:copy(a,a[1:])]
  完成
  
  a = []int{1, 2, 3}
  
  a = a[ :copy(a,a[1:])]		// 删除开头1个元素
  
  a = a[ :copy(a,a[n:])]		// 删除开头N个元素
  
3.从中间某个位置删除元素

	1）用append实现
	
	a = []int{1, 2, 3, ...}
	a = append (a[:i],a[i+1:])	// 删除中间1个元素
	a = append (a[:i],a[i+n:])	// 删除中间N个元素
	
	
	2）用copy实现
	a[:i+copy(a[i:],a[i+1:])]	// 删除中间1个元素
	a[:i+copy(a[i:],a[i+n:])]	// 删除中间N个元素

```

> ```
> 
> copy 函数的具体功能
> 
> slice1 := []int{1, 2, 3, 4, 5}
> slice2 := []int{5, 4, 3}
> copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
> copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
> 
> ```



#### **切片内存技巧**

`[0]int`的空数组，空数组一般很少用到。**但是对于切片来说，`len`为`0`但是`cap`容量不为`0`的切片则是非常有用的特性**。当然，如果`len`和`cap`都为`0`的话，则变成一个真正的空切片，虽然它并不是一个`nil`值的切片。在判断一个切片是否为空时，一般通过`len`获取切片的长度来判断，一般很少将切片和`nil`值做直接的比较。

场景：字符串转化为字节数组，但是字符串中可能含有空格，去除字节数组中的空格利用0长切片

```

func TrimSpace(s []byte) []byte{
	b=s[:0]
	for  _ ,v :=range s{
		if v != ' '{
			b=append(b,v)
		}
	}
	return b
}

```

根据过滤条件删除数组元素的算法都可以采用这种形式

```
func  Filter (s []byte,fn func(x byte) bool ) []byte{

	b = s[:0]
	for _,v := range s{
		if !fn(v){
			b = append(b,v)
		
		}
	}
	return b

}
```



**切片高效操作的要点是**

* 要降低内存分配的次数

* 保证append不会超出cap的容量

* 降低触发内存分配的次数，和每次内存分配的大小

  

#### **避免切片内存泄漏**

> 切片操作不会复制底层数据，底层数据会被保存在内存中，知道它不再被引用，但是，有时候可能因为一个小小的引用而导致底层数据被使用，这个会延迟自动回收器对底层数组的回收。

例如，`FindPhoneNumber`函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。

```go
func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return regexp.MustCompile("[0-9]+").Find(b)
}
```

**这段代码返回的`[]byte`指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。**

**要修复这个问题，可以将感兴趣的数据复制到一个新的切片中**

> 数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）

```go
func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = regexp.MustCompile("[0-9]+").Find(b)
    return append([]byte{}, b...)
}
```



> 返回数据尤其是返回切片时，要格外注意返回的切片对原始数据的依赖，如果对原始数据依赖性较强。
>
> 解决措施：
>
> 我们一般采用，把这个数据追加到一个新的空切片中
>
> append（[ ]int {},b）

**类似的问题，在删除切片元素时可能会遇到**

> 删除数据尤其是删除存放指针的切片元素时，删除末尾的元素后，被删除的元素依旧被切片的底层数组引用，从而导致不能及时的被自动垃圾回收器回收
>
> 解决措施：
>
> 先把需要自动回收的元素值设置为nil 保证自动回收器可以发现要被回收的对象
>
> 再进行切片的删除操作

```
var a []*int{ ... }

a = a[:len(a)-1]    // 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍
```

```
var a []*int{ ... }

a[len(a)-1] = nil // GC回收最后一个元素内存!!!!!!!!

a = a[:len(a)-1]  // 从切片删除最后一个元素
```

**当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收的了。**



#### **切片类型强制转换**



**为了安全，当两个切片类型`[]T`和`[]Y`的底层原始切片类型不同时，Go语言是无法直接转换类型的。不过安全都是有一定代价的，有时候这种转换是有它的价值的——可以简化编码或者是提升代码的性能。比如在64位系统上，需要对一个`[]float64`切片进行高速排序，我们可以将它强制转为`[]int`整数切片，然后以整数的方式进行排序（因为`float64`遵循IEEE754浮点数标准特性，当浮点数有序时对应的整数也必然是有序的）**

下面的代码通过两种方法将`[]float64`类型的切片转换为`[]int`类型的切片：

```
// +build amd64 arm64

import "sort"

var a = []float64{4, 2, 5, 7, 2, 1, 88, 1}

func SortFloat64FastV1(a []float64) {
    // 强制类型转换
    var b []int = ((*[1 << 20]int)(unsafe.Pointer(&a[0])))[:len(a):cap(a)]

    // 以int方式给float64排序
    sort.Ints(b)
}


func SortFloat64FastV2(a []float64) {
    // 通过 reflect.SliceHeader 更新切片头部信息实现转换
    var c []int
    aHdr := (*reflect.SliceHeader)(unsafe.Pointer(&a))
    cHdr := (*reflect.SliceHeader)(unsafe.Pointer(&c))
    *cHdr = *aHdr

    // 以int方式给float64排序
    sort.Ints(c)
}


```

> 第一种强制转换是先将切片数据的开始地址转换为一个较大的数组的指针，然后对数组指针对应的数组重新做切片操作。中间需要`unsafe.Pointer`来连接两个不同类型的指针传递
>
> 需要注意的是，Go语言实现中非0大小数组的长度不得超过2GB，因此需要针对数组元素的类型大小计算数组的最大长度范围（`[]uint8`最大2GB，`[]uint16`最大1GB，以此类推，但是`[]struct{}`数组的长度可以超过2GB）

> 第二种转换操作是分别取到两个不同类型的切片头信息指针，任何类型的切片头部信息底层都是对应`reflect.SliceHeader`结构，然后通过更新结构体方式来更新切片信息，从而实现`a`对应的`[]float64`切片到`c`对应的`[]int`类型切片的转换。

通过基准测试，我们可以发现用`sort.Ints`对转换后的`[]int`排序的性能要比用`sort.Float64s`排序的性能好一点。不过需要注意的是，这个方法可行的前提是要保证`[]float64`中没有NaN和Inf等非规范的浮点数（因为浮点数中NaN不可排序，正0和负0相等，但是整数中没有这类情形）















# Go类型系统概述

### 基本类型（basic type）

- 一种内置布尔类型：`bool`。
- 11种内置整数类型：`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`、`int`、`uint`和`uintptr`。
- 两种内置浮点数类型：`float32`和`float64`。
- 两种内置复数类型：`complex64`和`complex128`。
- 一种内置字符串类型：`string`。

一个布尔值表示一个真假。在内存中，一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（`false`和`true`）来表示。 关于常量声明，[下一篇文章](https://www.bookstack.cn/read/Golang101-v1.16.a-1/constants-and-variables.html)将做详细解释。

从逻辑上说，一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节（byte）序列。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式。 我们可以从[Go中的字符串](https://www.bookstack.cn/read/Golang101-v1.16.a-1/string.html)一文中获取更多关于字符串的知识。

尽管布尔和字符串类型分类各自只有一种内置类型， **我们可以声明定义更多自定义布尔和字符串类型**。 所以，**Go代码中可以出现很多布尔和字符串类型（数值类型也同样）**。 下面是一个类型声明的例子。 在这些例子中，`type`是一个关键字

```
// 一些类型定义声明
type status bool// status和bool是两个不同的类型
type MyStringstring// MyString和string是两个不同的类型
type Id uint64       // Id和uint64是两个不同的类型
type real float32    // real和float32是两个不同的类型

// 一些类型别名声明
type boolean=bool// boolean和bool表示同一个类型
type Text=string// Text和string表示同一个类型
type U8 = uint8     // U8、uint8和 byte表示同一个类型
type char= rune    // char、rune和int32表示同一个类型
```

### 基本类型的字面量表示形式

一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。

#### 布尔值的字面量形式

Go白皮书没有定义布尔类型值字面量形式。 我们可以将`false`和`true`这两个预声明的有名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。有名常量声明将在下一篇文章中介绍和详细解释。

布尔类型的零值可以使用预声明的`false`来表示

#### 整数类型值的字面量形式

整数类型值有四种字面量形式：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）。 比如，下面的三个字面量均表示十进制的15：

```
0xF// 十六进制表示（必须使用0x或者0X开头）
0XF

017// 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111// 二进制表示（必须使用0b或者0B开头）
0B1111

15// 十进制表示（必须不能用0开头）
```

### 概念：组合类型（composite type）

```
// 假设T为任意一个类型，Tkey为一个支持比较的类型。
        *T 		// 一个指针类型
   arr [5] T 	// 一个元素类型为T、元素个数为5的数组类型
   slice [] T 	// 一个元素类型为T的切片类型
 map[Tkey]T		// 一个键值类型为Tkey、元素类型为T的映射类型
				// 一个结构体类型
struct {
    name string
    age  int
}
			// 一个函数类型
func(int) (bool, string)
// 一个接口类型
interface {
	method1(string) int
	method2() (int bool)
    
}
// 几个通道类型
chan T
chan <-T
T<-chan 


```

### 语法：类型定义（type definition declaration）

```
// 定义单个类型。
type NewTypeName SourceType
// 定义多个类型。
type (
    NewTypeName1 SourceType1
    NewTypeName2 SourceType2
)
```



```
// 下面这些新定义的类型和它们的源类型都是基本类型。
type (
    MyInt int
    Age   int
    Text  string
)
// 下面这些新定义的类型和它们的源类型都是组合类型。
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
    // 这三个新定义的类型名称只能在此函数内使用。
    type PersonAge map[string]int
    type MessageQueue chan string
    type Reader interface{Read([]byte) int}
}
```



### 类型别名声明（type alias declaration



```
type (
    Name = string
    Age  = int
)
type table = map[string]int
type Table = map[Name]Age
```

**注意，尽管两个别名`table`和`Table`表示同一个类型，但`Table`是导出的，所以它可以被其它包引入使用，而`table`却不可以。**







