# Go数组和切片的内部实现原理



# 数组

几乎所有计算机语言，数组的实现都是相似的：一段连续的内存，Go语言也一样，Go语言的数组底层实现就是一段连续的内存空间。每个元素有唯一一个索引(或者叫`下标`)来访问。如下图所示，下图是`[5]int{1:10, 2:20}`数组的内部实现逻辑图:![image](https://i6448038.github.io/img/slice/array.png)

​	由于内存连续，CPU很容易计算索引(即数组的`下标`)，可以快速迭代数组里的所有元素。
​	Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝。你可以理解为Go语言的数组是一种有序的`struct`

# slice

![image](https://i6448038.github.io/img/slice/slice_1.png)

切片是一个很小的对象，是对数组进行了抽象，并提供相关的操作方法。切片有三个属性字段：长度、容量和指向数组的指针。

上图中，`ptr`指的是指向array的pointer，`len`是指切片的长度, `cap`指的是切片的容量。现在，我想你对数组和切片有了一个本质的认识。

对于`s := make([]byte, 5)`和`s := []byte{...}`的方式

![image](https://i6448038.github.io/img/slice/slice2.png)

对于`s = s[2:4]`的方式

![image](https://i6448038.github.io/img/slice/slice3.png)

对于`nil`的切片即`var s []byte`对应的逻辑图是![image](https://i6448038.github.io/img/slice/slice4.png)

> `nil`切片的指针为`nil`
>
> 空切片的指针不为`nil`

![image](https://i6448038.github.io/img/slice/slice5.png)

空切片指针不为nil，而nil切片指针为nil。但是，不管是空切片还是nil切片，对其调用内置函数`append()`、`len`和`cap`的效果都是一样的，感受不到任何区别。

## 扩容

- 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
- 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。

> 为什么要讲到扩容，因为我们不是拿切片来操作数组嘛，对数组中的值进行修改等等一系列操作，但是如果切片在我们的不断扩容中，超过了原来的数组的容量，那么切片就会变了，切片指针指向的地址不再是原来的数组了，这个时候，go会开辟新的内存，把原来数组的值复制过来，然后让这个切片指向新开辟的数组的地址。

