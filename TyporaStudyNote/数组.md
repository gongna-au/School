# C 语言数组

**C 语言数组属于构造数据类型。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类**
**型**

### 数组内存是连续的

**连续的内存为指针操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）**

也就是说：因为数组是连续的，所以我可以通过指针来访问数组元素，或者大块大块的复制数据或者写入数据。

**这里数组的本质是：临时储存数据的一块内存！！！**

### 字符串结束标志（划重点）

* 由" "包围的字符串会自动在末尾添加'\0'

* "abc123"从表面看起来只包含了 6 个字符，其实不然，C 语言会在最后隐式地添加一个'\0'，这个过程是在后台默默地进行的，所以我们感受不到。

* 逐个字符地给数组赋值并不会自动添加'\0'

  ```
  char str[] = {'a', 'b', 'c'};
  
  char str[]="sjafbjs   ABVFJALSBV";
  这两种在内存中的存储方式是不一样的！！！
  还有！！空格也会在内存中占据内存，这和scanf从缓冲区读取到某个地址是不一样的！！！
  scanf（）会尝试忽略一些空格进行匹配，但是你直接赋值，而且用""来赋值，空格也会占据内存空间！！！用""来赋值，不仅仅里面的空格会占据内存！！而且会在末尾加上\0!!!!
  
  
  ```

  

* **程序的逻辑要求我们必须逐个字符地为数组赋值,逐个字符为数组赋值时，一定一定要在最后用\0来赋值作为结束！！！！**

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
void main(){
    char str[27];
    char ch;
    for(int i=0,ch='A';i<27;i++,ch++){
        if(i==26){
            str[26]='\0';
            continue;
        }
            str[i]=ch;
}
    printf("%s",str);

}
```



**注意的一点是！！！在你知道字符个数的情况下，你定义的字符个数，要比你知道的字符个数大1，循环赋值条件是<字符个数+1；但是在最后用\0来赋值时，下标是字符个数+1-1**，**如上，26个字符定义27个循环条件<27,最后的赋值条件为str[26]='\n'**

* 在很多编译器下，局部变量的初始值是随机的，是垃圾值，而不是我们通常认为的“零”值。局部数组（在函数内部定义的数组，本例中的 str 数组就是在 main() 函数内部定义的）也有这个问题，很多编译器并不会把局部数组的内存都初始化为“零”值，而是放任不管，爱是什么就是什么，所以它们的值也是没有意义的，也是垃圾值.
* **在函数内部定义的变量、数组、结构体、共用体等都称为局部数据**

也就是说定义在函数内部的变量，数组，结构体，共用体，不会把数值初始化为零值。**在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的“零”值。这一点非常重要，大家一定要谨记，否则后面会遇到很多奇葩的错误**

所以说\0很重要很重要！！！！**不注意'\0'的后果有多严重，不但不能正确处理字符串，甚至还会毁坏其它数据**。



1. 处理方法一

```
#include <stdioh>
int main() {
	char str[30];
	char c;
	int i;
	for (c = 65, i = 0; c <= 90; c++, i++) {
	str[i] = c;
	}
	str[i] = 0; //此处为添加的代码，也可以写作 	str[i] = '\0';
	printf("%s\n", str);
	return 0;
```

2.处理方法二

**但是，这样的写法貌似有点业余，或者说不够简洁，更加专业的做法是将数组的所有元素都初始化为“零”值，这才能够从根本上避免问题！！！！。再次修改上面的代码：**

```
#include <stdioh>
int main() {
	char str[30]={0};
	char c;
	int i;
	for (c = 65, i = 0; c <= 90; c++, i++) {
	str[i] = c;
	}
	
	printf("%s\n", str);
	return 0;
```

**我之前把到底什么时候才会给一些数组初始化零值没搞清楚？**

**答：初始化部分数组元素，那么剩余的数组元素也会自动初始化为“零”值，所以我们只需要将 str 的第 0 个元素赋值为 0，剩下的元素就都是 0 了**

#### 结论是：初始化部分数组元素！！注意姐妹，是初始化！部分！！！元素！剩余的元素自动初始化为零值。凡是在函数中定义的，都是局部的，你不给它部分初始，它就是随机的！！！

#### 请牢牢记住：没有部分初始，局部变量就是随机的！

#### 在定义字符数组时都给我用0去部分初始化数组！！从根本上解决字符串最后\0的问题！！因为\0的ASCII就是0！！！

### 字符串长度

在 C 语言中，我们使用 string.h 头文件中的 strlen() 函数来求字符串的长度。

length strlen(strname);

strname 是字符串的名字，或者字符数组的名字；length 是使用 strlen() 后得到的字符串长度，是一个整数。

### 字符串的输入



* scanf()：通过格式控制符%s 输入字符串。除了字符串，scanf() 还能输入其他类型的数据
* gets()：直接输入字符串，并且只能输入字符串
* scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。
* gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空
  格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说，gets() 用来读取一整行字符串。

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
void main(){
    char str[27]={0};
   
    str="sjdaks";

}

这么写错误的原因是什么？？
答：问题出在赋值号上，赋值号的左边只能是变量
这里str可以理解为指向字符数组下标为0的指针，
也可以理解为一个首地址常量，常量不能做左值，错误
给一个指向下标为0的指针赋值为字符串也错误。

```

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
void main(){
    char str[27]={0};
   
   scanf("%s" str);

}
这个写是对的，是因为是要把获取的字符串放到str地址里面。
但是如果是为字符数组的每个下标赋值
 scanf("%s" &str[0]);
 一是要加下标！！
 二是要加取地址符！！

```

注意，scanf() 在读取数据时需要的是数据的地址，这一点是恒定不变的，所以对于 int、char、float 等类型的变量
都要在前边添加&以获取它们的地址。但是在本段代码中，我们只给出了字符串的名字，却没有在前边添加&，这
是为什么呢？因为字符串名字或者数组名字在使用的过程中一般都会转换为地址，所以再添加&就是多此一举，甚
至会导致错误了

就目前学到的知识而言，int、char、float 等类型的变量用于 scanf() 时都要在前面添加&，而数组或者字符串用于scanf() 时不用添加&，它们本身就会转换为地址。读者一定要谨记这一点

### C 语言字符串处理函数

用于输入输出的字符串函数，例如 printf、puts、scanf、gets 等，使用时要包含头文件 stdio.h，而使用其它字符串
函数要包含头文件 string.h

### C 语言数组是静态的，不能插入或删除元素

**在 C 语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为静态数组**

> C语言里面的数组，定义好后你就不能删除某个下标的元素，或者在某个位置插入元素，但是你可以修改它！！读取它！！！

总之，C 语言中的数组是静态的，一旦定义后长度就不能改变了，大家要注意这一点，不要尝试去插入或删除
元素。

**如果由于项目要求，必须要在数组中插入或者删除元素，该怎么办呢？没办法，只能再造一个新数组！**

### C 语言数组为什么是静态的

* 在第 i 个元素后面插入一个新元素时，第 i 个元素后面的所有元素都要往后移动一个元素的位置，从而给新元腾出位置来。如果该数组后面紧跟的是其它有用数据，那么为了防止覆盖有用数据，还不敢直接往后移动元素必须得重新开辟一块内存，把所有的元素都复制过去
* 删除第 i 个元素就比较简单了，不管三七二十一，把第 i 个元素后面的所有元素都向前移动即可。

**插入和删除数组元素都要移动内存，甚至重新开辟一块内存，这是相当消耗资源的。如果一个程序中有大量的
此类操作，那么程序的性能将堪忧，这有悖于「C 语言非常高效」的初衷，所以 C 语言并不支持动态数组**

另外，很多时候我们需要把数组的地址保存到一个变量里面（等大家学到指针时就会见到这种情况），如果数
组重新开辟了内存，而变量里面的地址不跟着改变的话，后续再使用该变量就会导致错误。让 C 语言本身去维
护这些变量的值，以保持同步更新，这又是不可能做到的，所以这个矛盾无法从根本上解决

### 数组越界

C 语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，就发生了越界（Out Of 
Bounds），访问到数组以外的内存。如果下标小于零，就会发生下限越界（Off Normal Lower）；如果下标
大于等于数组长度，就会发生上限越界（Off Normal Upper）。

C 语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，即使越界了，也能够正常编译，只有
在运行期间才可能会发生问题。请看下面的代码

```
#include <stdio.h>
int main(){
	int a[3] = {10, 20, 30}, i;
	for(i=-2; i<=4; i++){ 			printf("a[%d]=%d\n", i, a[i]); 
	} 
	return 0;}
```

运行结果：a[-2]=-858993460

a[-1]=-858993460

a[0]=10

a[1]=20

a[2]=30

a[3]=-858993460

a[4]=-858993460

**越界访问的数组元素的值都是不确定的，没有实际的含义，因为数组之外的内存我们并不知道是什么，可能是**
**其它变量的值，可能是函数参数，可能是一个地址，这些都是不可控的。**



**由于 C 语言的”放任“，我们访问数组时必须非常小心，要确保不会发生越界。每个 C 语言程序员的生涯中都**
**遇到过越界错误，我拿项上人头作保证，所以千万不要大意，因为越界错误有时候不容易发现，也不容易复现**

**当发生数组越界时，如果我们对该内存有使用权限，那么程序将正常运行，但会出现不可控的结果（如上例所**
**示）；如果我们对该内存没有使用权限，或者该内存压根就没有被分配，那么程序将会崩溃***

**每个程序能使用的内存都是有限的，该程序要访问 4*10000 字节处的内存，显然太远了，超出了程序的访问范围。这个地方的内存可能没有被分配，可能是系统本身占用的内存，可能是其它数据的内存，如果放任这种行
为，将带来非常危险的后果，操作系统只能让程序停止运行。**

一般情况下数组溢出不会有什么问题，顶多是丢失多余的元素。但是当以字符串的形式输出字符数组时，就会产生不可控的情况，请看下面的代码：

**字符串的长度大于数组长度，数组只能容纳字符串的前面一部分，也就是"http://c.b"，即使编译器在最后添加
了'\0'，它也保存不到数组里面，所以 printf() 扫描数组时不会遇到结束符'\0'，只能继续向后扫描。而后面内
存中的数据我们不知道是什么，字符能否识别，何时遇到'\0'，这些都是不确定的。当字符无法识别时，就会出
现乱码，显示奇怪的字符。**

**由此可见，在用字符串给字符数组赋值时，要保证数组长度大于字符串长度，以容纳结束符'\0**

### 普通数组（固定长度的数组）是在编译期间分配内存的，而变长数组是在运行期间分配内存的。

变量的值在编译期间并不能确定，只有等到程序运行后，根据计算结果才能知道它的值到底是什么，所以数组
长度中一旦包含了变量，那么数组长度在编译期间就不能确定了，也就不能为数组分配内存了，只有等到程序
运行后，得到了变量的值，确定了具体的长度，才能给数组分配内存，我们将这样的数组称为变长数组!!

```
scanf("%d",&n);

int arr[n];
```

这就是一个典型的变长数组！！！

它的内存分配是在运行期间获得N的值后分配内存的！！！

**变长数组仍然是静态数组**

* **注意，变长数组是说数组的长度在定义之前可以改变，一旦定义了，就不能再改变了，所以变长数组的容量也
  是不能扩大或缩小的，它仍然是静态数组。以上面的代码为例，第 8 行代码是数组定义，此时就确定了数组的
  长度，在此之前长度可以随意改变，在此之后长度就固定了**

### C 语言函数

**你可以通过控制次数来控制循环进行多少次，但是如果我们主观上不知道要循环多少次，那我们就去寻找特征，或者标志它结束的那一个特征！！！！比如说字符串是以"\0"结尾的，这就是一个非常非常重要的条件**

* 如果我们主观上不知道要循环多少次，那我们就去寻找特征，或者标志它结束的那一个特征！！！！比如说字符串是以"\0"结尾的，这就是一个非常非常重要的条件

* 如果不是需要每次都进行判断，那你for循环里面的条件判断可以不写，换成Break跳出！！！！

* 常见的内层循环更新标志变量，更新下标。

  通常意味着，只要那么多次循环里有一次什么什么，我就怎么怎么。如果一次都没有，意味着怎么怎么.......

  

#### **函数不能嵌套定义，main 也是一个函数定义，所以要将 sum 放在 main 外面。函数必须先定义后使用，所以 要放在 main 前面**

>  main 是函数定义，不是函数调用。当可执行文件加载到内存后，系统从 main 函数开始执行，也就是说，系统会调用我们定义的 main 函数

无返回值函数

* 有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，
* **void 是 C 语言中的一个关键字，表示“空类型”或“无类型”，绝大部分情况下也就意味着没有 return 语句。**

C 语言有参函数的定义

* 数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部
* 参数列表中给出的参数可以在函数体中使用，使用方式和普通变量一样
* 调用 sum() 函数时，需要给它传递两份数据，一份传递给 m，一份传递给 n。你可以直接传递整数，
* 也可以传递变量：
* 函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简
  称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。
* 函数不能嵌套定义
  强调一点，C 语言不允许函数嵌套定义；也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。



### 形参和实参的区别和联系

*  形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。
*  实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。
*  函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。

* **函数调用中发生的数据传递是单向**，也就是说，就是把实参的值赋值给了形参，你如果操作形参，实参在外部又没有发生变化！！
*  形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效



###  函数返回值（return 关键字）精讲

函数的返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果通过 return 语句返回

* return 语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个 return 语句被执行
*  函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。从这个角度看，return 语句还有强制结束函数执行的作用。
* **通常使用标志变量时，如果在循环外部假设它是，那么，在内部那么多次循环中，只要有一次对标志变量的值进行更改，说明不是**

